brian you can open the second room too
there we go
all right this is cs50 and this is
week one our second week and today
recall that we'll we'll focus on
this other programming language called c
and we gave you a little glimpse of this
last time
where and i propose that this code here
on the screen is something that you
will soon know how to program if not
already but suffice it to say it looks
quite a bit dissimilar
to what we looked at last week which of
course was scratch which was much more
playful much more graphical
and so allow me to disclaim right from
the get-go today that
uh for most of us today will feel like a
bit of a fire hose in fact pictured here
is an old hack from mit
wherein some industrious seniors hooked
up an actual fire hydrant to a water
fountain
uh the saying being that getting an
education from mit is like drinking from
a a
fire hydrant today will feel a little
bit like that because this is sort of a
special occasion
that you don't really have occasion to
describe very often but it's one in
which we're all going to learn
a new language and indeed that's not
something we do every day and so at the
first glance it's going to look like a
lot of new syntax a lot of new ideas and
yet
allow me to reassure that what will soon
look like this
this c code here is fundamentally the
same thing that you've
seen and now experimented with last week
by way of scratch
that is to say within this other
programming language c which is more
traditional which is more text based
more keyboard based
we're still going to see functions
conditions boolean expressions loops
and so on they're going to all look a
little different but
the ideas are the same and so much like
when uh walking into someone's home for
the very first time and getting the lay
of the land and seeing a lot of things
that you haven't seen before
you typically don't care about all of
those visual details you might just
simply
walk forward and sit down or perhaps uh
uh and begin your conversation similarly
today we're about to see a whole lot of
details in the world of this programming
language
but the goal at hand is to ignore things
at first glance that we don't
necessarily
understand and latch on to those ideas
that are familiar
from last week so how do we go about
actually
writing computer programs how do we go
about uh writing them well
and so allow me to propose that there's
a few guy a few
guiding lights that should guide writing
of code one of course is correctness and
we explored this last week whereby the
correctness of your code just speaks to
does it work as intended when you
double-click some icon when you run some
command
does the program that you or someone
else wrote behave correctly does it do
what it says
but there's other aspects to writing
good software
and writing good programs and that has
to do with design and we alluded a
little bit to this last week but with
design it's more of a qualitative a more
subjective measure
just how well written your code is so
imagine for instance from taking a class
where you have to write
essays you could certainly make very
correct arguments
but you could make very correct
arguments by writing very long
rambling sentences repeating yourself
and generally not
writing a very good essay or paper now
it might be correct
there's nothing in that paper for your
english class history class or whatever
it may be
that you said that was incorrect but you
might not get very good marks on it
because it's just not very well
designed and so similarly in the
programming world is there this notion
of actually writing not only correct
code
but well-designed code wherein you don't
repeat yourself
you write code that's fairly efficient
it doesn't do more
uh more work than it actually needs to
and then lastly let me propose for today
onward in this class
that there's a third access you should
keep in mind when it comes to writing
good code and that has to do with style
this is much more of an aesthetic
so this in the analogous world of
writing an essay would be
are you using good punctuation
capitalization
are you indenting new paragraphs and
those kinds of aesthetics
that fundamentally don't change the
correctness of what you're saying
don't change necessarily the quality of
the arguments that you're making
but the style of your essay much like
the style of your code
makes your code much much more readable
so when it comes to
writing good code you want it first and
foremost to be correct but also well
designed
and also well styled much like again you
would when writing an essay that you
would hope would reflect well
on your capabilities as well
so when it comes to writing code like
this for instance this first c program
that someone last week proposed quite
simply
prints out on the screen hello world
well how do we go about writing this
code last week we wrote code
by going to scratch.mit.edu and then
dragging and dropping
puzzle pieces today is going to be a
little different we're going to use a
different tool here on
out and we're going to use our keyboard
much more than our mouse to actually
program
but to do so we're going to go ahead and
introduce the first of several tools
this semester
this one known as cs50 ide ide
is an acronym a term of art in
programming that stands for integrated
development environment which is just a
fancy way of saying in this context that
cs50 ide
is cs50's own web-based programming
environment and it's not
specific to cs50 per se we've simply
added a number of educationally useful
features
on top of a third-party cloud tool
that anyone on the internet can use and
our own version thereof lives at this
url ide.cs50.io so you're welcome to
follow along at that url today but you
need not
during lecture itself but on this coming
upcoming problem set and beyond will you
actually use
and get more familiar with this tool
hands-on so let me go ahead and open up
this tool here so i've already logged in
in advance
and what you see here is the basic user
interface that's available to you
and fortunately there's only a couple of
salient features that we need point out
right now
so at the top of the screen here is just
a big black rectangle that in a moment
is going to be filled with code much
like using google documents or something
like that where you can create new tabs
and create new files
this is where i'm going to do my
programming along the top of the screen
and along the bottom is what we're in a
moment going to start
calling our terminal window it's in this
terminal window
that i can actually run commands and
ultimately run
my actual code but let's go ahead and
write our very first program in this
environment
and realize that this tool indeed is not
very cs50 specific it's meant to be
representative
of a very common popular programming
environment where you have a so-called
text editor
or tabbed windows where you can write
code and a terminal window where you can
actually run commands ours happens to
exist in the cloud but you can
alternatively
program certainly on your own mac or pc
or any other device these days
but frankly it tends to involve just a
non-trivial number of technical
difficulties early on especially when we
all have different versions of mac os
and windows and the like
so this cloud-based environment just
ensures that on day zero
we can all have the same exact
programming experience
so i'm gonna go ahead and do this i'm
gonna go ahead and go up to file and new
file
and this is gonna create a new tab by
default called untitled
not very interesting so i'm going to now
go up to file and save
and by default i'm going to save this
file as for instance the name
hello.c so i want to write my very first
program
in this language called c i'm going to
call my file hello but i'm going to end
it in a file extension
called dot c and that's indeed the
convention when writing
c programs they should end with dot c
just like scratch programs as you may
recall end in dot
sb3 so i'm going to go ahead and simply
click the green button
here that's called save nothing is
really going to change except for the
name and the tab there
now i see a top left that this tab is
called hello.c
and now i can start typing anything i
want and frankly i'm just going to type
from memory
the very first program we saw last week
and just a moment ago
i'm going to do include standard io dot
h whatever that is for now
i'm going to going to do int main void
whatever that is for now
i'm going to use a curly brace and then
close that curly brace so to speak
thereafter and in here i'm going to go
ahead and do printf
quote unquote hello world followed by
a semicolon now that was a whole lot of
text right off the top of my head
this is the kind of muscle memory that
you'll soon develop when writing a
program i've of course done this
many times before so i was able to just
do it off the top of my head but in a
moment
we'll tease apart what all of the
various lines and characters that i
typed
actually do but what i'd now like to do
is run this program we conjectured last
week
that this is just going to print hello
world but how
well in the world of our macs and pcs
and phones we would all just tap an icon
if we want to actually run a program
that's not going to be the case today
because now we're in more of a
traditional programming environment
the environment that we're now in
requires that i use my keyboard
a little bit more or what's known as a
command line interface or cli
this is in contrast with a graphical
user interface or
gui or gui which is what describes mac
os windows ios and
android but in a command line interface
i have to do everything
at a so-called command line and by that
i'm referring to this blinking prompt
along the bottom
reported along the bottom of my screen
here again i described as the terminal
window
where i'm going to type commands and
this is my command line interface
anything i type here is going to get
sent to this computer
and hopefully execute uh on its own
hardware so
how do i do this and what do i do well
the catch of course
is that when writing code in c or python
or java or bunches of other languages
that happen to exist
that's really meant to be written and
understood by me and you the humans
but per last week what is the only
language in a sense that computers
understand brian could we
call on someone for this what language
do computers
only speak
because i think there's a disconnect
between where we left off last week and
where we're currently at
if i'm writing code that now looks like
this cindy
what language do computers speak would
you say
um binary binary and just elaborate a
little bit what do you mean by binary to
recap
yeah so they use ones and zeros to
represent everything
exactly they use ones and zeros to
represent everything and last week we
focused on only things like numbers and
letters then colors and
images and videos and sound and so forth
but we didn't all
actually speak to built-in functionality
which computers also use zeros and ones
to represent that is to say computers of
course have the ability these days
to print something on the screen and
that notion of printing that
function that functionality also is
represented
underneath the hood of a computer so to
speak by some pattern of zeros and ones
which is to say that everything i just
typed even though it kinda sorta looks
like english and kinda sort of
clearly says print hello world the
computer
ironically does not know what it is i
have just typed
in order for to understand what i've
just typed i need to actually convert it
to zeros and ones and so indeed the next
step in this process is to take what
i'll describe as my source code
written here in c and last week too we
saw source code it was just graphical it
was those puzzle pieces in scratch
this is my source code that even though
cryptic is something i at least the
human eventually can read and write
but i need to literally convert it to
patterns of zeros and ones that the
computer can understand
now how do i get to this point well
thankfully we have a mental model from
last week
that involves problem solving and here's
a problem how do i take source code
written in this language supposedly
called c
and convert it to zeros and ones that
the computer understands
well my input i dare say is going to be
my source code
and my uh output ideally is going to be
what we'll call
machine code machine code is just a term
of art describing the zeros and ones
that computers understand
we didn't use that expression last week
but this just refers to zeros and ones
on the right
and c code on the left so that invites
the question well what is between my
source code
and machine code if i take my source
code and feed it into the proverbial
black box
how do i get out of this black box the
zeros and ones that the computer
understands
well i need a special program that we're
going to start calling a compiler
a compiler is a program that you can
download for free
or pay for back in the day that is a
program design
to convert source code to machine code
so all i need do
if i want to actually solve the problem
as stated earlier whereby
i have written this code in c and i now
need to convert it to zeros and ones i
just need to give myself access to
a compiler and it turns out one of those
exists within cs50 ide
and this is a tool you could download on
your own mac or pc or the like
and for now we're going to describe that
tool as being quite simply called
make literally if i want to make my
program
i'm going to go ahead and type make
hello and then i'm going to run it with
a little bit of a cryptic syntax
dot slash hello but let's see that in
action to tie this all together
i'm going to move my cursor down into my
terminal window
or my command line interface and i'm
going to literally type hello
notice i am not typing make hello dot c
i'm typing the name of the program i
actually want to make and i just want to
call this program
hello the compiler is going to infer
from this command
that i actually intend to compile a file
called hello.c
i'm going to go ahead and hit enter
there's some crazy cryptic output more
on that another day
but the fact that i don't see any big
scary red error messages is a good thing
this means that my program compiled
successfully why
there's just no yellow or red messages
to say otherwise
but now if i want to actually run this
program i need to type a different
command that's the analog of double
clicking an icon on your mac or pc or
phone
i'm going to type literally dot slash
dot slash hello essentially is like
saying go into the current folder
on the computer i'm using and look for a
program called hello
i'm going to go ahead and hit enter and
voila hello world
now i see again a dollar sign and some
other text on the screen and we'll tease
apart in just a bit what this means
but notice this dollar sign is just a
constant visual reminder
of where my prompt is where i can type
more commands
and the computer has done literally what
i asked it printed out hello world and
now it's waiting for my second command
so that was the analog of just printing
hello world out of
the cat's mouth last week but surely we
can do
more than this but let's tie it back to
what we did last week as well
so that not everything here is all that
dissimilar
so recall that last week we had
functions and it turns out we had
something called
arguments even though we didn't
necessarily describe them as such so a
function
is like a mini program it's an action or
a verb that you can use when writing
your own program
that does something we saw the say block
last week we saw the wait block last
week those were
verbs or actions or more generally known
as functions but functions can also take
inputs recall and we did see that last
week and nowadays we're going to start
calling
inputs to functions arguments so to
speak another term for them is
parameters but for all intents and
purposes those are
synonyms for our purposes arguments are
the inputs to functions
so let's consider then from last week
this say block that we saw last
time which simply is trying to say out
of the cat's mouth hello world
well let me go ahead and convert this if
you will to corresponding c code
just to emphasize how similar
fundamentally
these two languages are even though
syntactically c absolutely looks
uh visually different it turns out that
if you want to say something
in c using this text-based language like
i just did
you're not going to write se you're
instead going to write print that's
actually a bit of a white lie you're not
going to say print you're actually going
to say
print f for reasons we'll eventually see
it means print a formatted
something or other so printf is the
analog in c
of say in scratch now notice in c i've
got this open parenthesis and closed
parenthesis that nicely enough are kind
of ovular in shape and notice that they
kind of mimic the white oval
into which we provided input last week
so in between those parentheses
are going to be my inputs to this
function printf otherwise known as
arguments but they're going to be a
little different this week i yes i'm
going to say hello world
with a comma in between grammatically
just like last week but in the world of
c
i have to be a little more particular i
also have to add double quotes
on the left and the right and somewhat
annoyingly i also have to add
a semicolon at the end of this line of
code so just like in english or in a lot
of human languages you end a sentence
for instance with a period
in many lines of code you will write and
see
you've also got to finish your thought
in this case with a
semicolon so this then on the right is
the closest way of translating
this thing on the left from scratch to c
respectively
so the ideas are still the same but the
syntax looks a little different and we
just got to ingrain in ourselves
ultimately
what these patterns are and what these
human conventions are but notice that
what we just did follows the same
paradigm
as last week but let's add a little more
terminology this week
last week we described the black box as
potentially being algorithms
initially and then we started calling
them functions functions are just a
programmed version of an algorithm the
implementation of an algorithm in code
in software so a function might be
represented here as taking inputs
otherwise
known now as arguments but it turns out
that functions can do at least two
different types of things
in the world of programming and we've
seen these things already but we didn't
describe them quite as particularly as
we will today
when a function takes inputs that is to
say arguments just like
hello world is an input to the say block
in scratch or the hell
or the printf function in c
functions can have what are called side
effects and recall we did see this last
time
when we used the say block it did output
something but more technically it had a
side effect a visual side effect when i
used the say block last week
and the printf function this week you
see something on the screen
and that is yes some form of output but
it's a little different from a different
form
of output that we saw last time so a
side effect of a function
is often something visual that happens
on the screen
like text or audio in that case but
there's this other feature of functions
that we're going to see and leverage
today known as return values where a
function can
really just hand you back a value it's
not going to say it on the screen it's
not going to
vocalize it audibly it's going to just
pass it back to you in a way that you
the programmer can reuse
whatever the output of that function was
ideally storing it even in a variable
so for instance recall last week that we
asked the human their name
by way of this ask block and the input
to the ask block
in this white oval was what's your name
and then recall that this ask block was
a little special last week
because it gave us access to whatever
the human ultimately typed in
and that is to say that the ask block
last week
essentially returned a value it didn't
just blindly
display whatever word the human typed in
on the screen no
it instead returned it in some sense
metaphorically
and stored it in a special variable
called answer
and so again that's the difference the
say block literally says something on
the screen and there's an immediate
visual effect
with the ask block after you type in
your name you don't
see your name printed or displayed again
on the screen instead your name is sort
of tucked away in a variable just like a
mathematician would store a number
in a variable like x or y or z the onus
was then on us the programmer last week
to eventually
do something with the value my name
that was in that variable called answer
so how are we going to translate
last week's ask block to c this week
well it turns out there's different ways
to do this in c
none of which are very easy unless you
use what's called a library
a library is code that someone else has
written and indeed one of the things
we'll use today
is the so-called cs50 library which is a
bunch of code not terribly much that the
staff and i
wrote just to make it easier to do
simple things these are training wheels
of sorts that will take off
completely within a few weeks time but
in order to get started quickly it's
going to make it easier to do things
like getting text from the user
so string is a term of art in the
programming world a string
is text it's a word it's a letter it's a
paragraph it's a page of text it's just
text in some form string is what a
computer scientist would call text
getstring is a function that we wrote
that we will provide to you
that does take inputs notice per the
parentheses here in c
it can take input what might that input
be well just like the ask block it's
going to be a prompt
that the human should ultimately see so
there's a bit more involved though than
just using this function
when you use get string in c as we will
soon see in a live demo
you want to do something with the
human's name and to do something with
the human's name it's not quite
sufficient to just trust that scratch
will put it in a variable for you
in c as with most programming languages
it's a lot more pedantic like if you
want something to end up in a variable
you've got to do it yourself mit is not
going to magically put it in an answer
variable for you you have to do it
yourself
so to do this you simply come up with
the name of the variable that you want
be it x or y or z or more compellingly
answer and you use an equal sign a
single equal sign
and even though in math this generally
implies equality
in the context of c in most programming
languages
the equal sign actually means what we'll
call assignment
it means effectively copy whatever is on
the right
into whatever's on the left so if on the
right hand side there's a function whose
purpose in life is to ask the human what
their name is
that name is going to get copied from
right to left ultimately
into this variable called answer mit did
that automatically for us in scratch
in c you have to do it yourself but you
have to be a little more particular too
it turns out that in the world of c you
can't just have variables you have to
tell the computer in advance what type
of variable you want
and specifically i'm going to tell the
computer that the type of variable i
want is going to be a string and the
convention for doing so
is you literally write the name of the
type that you want
string being the only one we've seen
thus far then you write the name of the
variable
and then again to assign a value to that
variable from right to left
we have to use the single equal sign
here and now just a quick pause
brian if we could call on someone for
this even if you've never programmed
before
if you've taken to heart one of my
pieces of advice earlier
i'm still missing something how might i
want to
finish the translation of this scratch
code to see on the right hand side what
is missing
from what you can tell if you've
programmed before odds auto will jump
right out if you've never programmed
before
you'll have to think back on what i said
earlier jacob what do you think
uh semicolon exactly there's just one
single stupid semicolon missing at the
end of the line
which is necessary to make clear to the
computer that this is the end
of this thought and i sort of impugned
it as stupid because honestly
one of the biggest frustrations when
learning how to code as will now happen
today and this week and beyond
is initially you're going to forget
stupid things like the semicolon or
you're going to forget a single quote
mark
or a parenthesis or things like this and
the most important like advice i can
give today is this
try not to get frustrated by those kinds
of stupid things it's a lot more
interesting it's a lot more useful in
life to understand functions and loops
and conditions
and not to let yourself get frustrated
by the more minor aesthetic things
that honestly will just come with
practice so if the very first mistake
you make
is missing a semicolon and it takes you
10 minutes an hour to figure out
what is wrong with your code totally
normal and that those frustrations go
away
quite quickly in time so
we then have this translation of one
function to another
where else can we take it from here well
let's take a look at one
other translation that we used after
that ask block last week
after we asked the human their name as
by providing an input to the function
and getting some output we then
proceeded to do something
with the return value or output of ask
again we asked the human their name
scratch magically last week put the
name into the answer variable but then i
did something with it and this is what i
mean
to distinguish side effects which just
kind of happened to you
like something printing on the screen
like the cat saying something
out of its mouth versus a return value
which is a piece of information like a
name a human has typed in
being stored somewhere where you the
programmer can make use of it
later it's not happening to you it's
being handed to you for subsequent use
and last week in order to say hello
comma world all in one breath so to
speak
we kind of had to stack these puzzle
pieces on top of one another making the
output of join
the input of say in c this is actually a
little easier even though it's some new
syntax
again printf is going to be the analog
for say and we've seen that
a moment ago we're still going to have
the parentheses we're still going to
have the semicolon so what goes inside
now the input
how do i provide hello comma answer
to c well i'm going to go ahead and do
hello comma
in double quotes but then this strange
new
syntax here percent s this is what we're
going to call a format
code a format code and hence the f in
printf
printf doesn't just print things it can
print format codes as well
and this is just fancy syntax for saying
plug in
some actual value here don't print out
percent s literally
this is a placeholder for what will be s
a string well what do i want to put
there here's something new too
in scratch if you had two inputs to a
function you would have two ovals like
this
and this one here that you could either
type words or numbers into or drag
variables into in c there's no notion of
ovals or graphics at all
so instead we're just going to go old
school and just use a comma
if you use a comma in between the
parentheses
as the arguments or inputs to a function
that's going to separate the one on the
left
from the one on the right thereby being
analogous to having two ovals
in the world of scratch now there's
something that's potentially a little
visually confusing here
there's actually two commas here of
course and here
but notice the important detail that
first one that's an english grammatical
comma
that i've put inside of my quoted string
my quoted phrase of text that has
nothing to do with programming that just
has everything to do with english the
fact that this comma is outside of those
double quotes though
means it's significant in this language
called c and it separates first argument
from second argument and so in this way
do we have the ability now to also
say something on the screen using uh
printf in this slightly new way so let
me go ahead then
and do this for real let me go back to
cs50 ide and i'm going to go ahead and
go back into this program here
and consider for just a moment how we
can improve upon this very first program
which
literally just prints hello world not
that interesting i can run it all day
long it's going to say the same thing
how do i now get input from the user
well it turns out
that i can simply enhance this code a
little bit let me go ahead
and per the translation of scratch
earlier
let me do something like string answer
equals get underscore string
quote unquote what's your name so i'm
literally typing out what we saw in c a
moment ago i'm going to remember my
semicolon over here
and then i have to change the second
line of code now to not say hello comma
world but instead to say hello
comma percent s and then outside of the
double quotes i'm going to do a comma
and then provide literally the word
answer which is the name of that
variable
but i'm not quite done and this is a
little subtle and invariably you'll
forget this at some point too
in order to use get string i have to use
this thing called the cs50 library
code that the staff wrote that you don't
have default access to and in order to
do that
i need to add one line of code that will
explain in more detail in a little bit
but for now just take it on faith that
by adding this line of code
at the very top include cs50.h
that will now give me access to the
getstring
function which i otherwise wouldn't have
access to all right now i'm going to go
back to the terminal window
and notice the dichotomy here if i just
run dot slash hello
sort of enthusiastically let's see what
my new program does i'm about to be
unfortunately disappointed because it
still says hello world and you might
realize intuitively what the problem of
course here is i haven't actually
recompiled the code and so anytime you
make a change to your code it does not
suffice to just save the file via file
save or control or command
s i need to recompile it and to
recompile my code that's not such a big
deal
i just type make hello enter cross my
fingers that there's no yellow or red
scary text
this is all good it seems to have
compiled into machine code
now i can retype dot slash hello and
enter and you'll see now my program is
running and waiting for me let me go
ahead and type my name david enter
hello comma david let me go ahead and
run it again after clearing the screen
let me run it again and this time
let's say my name is brian and i see
hello comma brian
so quite similar to what we did in
scratch but now we're more powerfully
doing this all thus far
via my keyboard alone
all right so that was a lot we wrote
hello world super quickly off the top of
my memory and then enhanced it to now i
take input from the user
let me pause here if there are any
questions you're welcome to ask via chat
for either staff or classmates to answer
but if you'd like to raise your
virtual hand and zoom please feel free
so that i can
clarify or expound on anything here
any questions brian from the group
yeah question from uh ryan
sorry is that doing me that asks us in
the chat but
so the string before the answer that's
not the name of the variable
so you could hypothetically make it like
string que
you can make it like string a or string
anything else it just matters what comes
after string is the name of the variable
exactly really good question in the
world of scratch you were required to
use the variable called
answer in c we have the complete
flexibility over what we want to do so
as ryan proposed
i could change my variable's name to
just a for short
i would have to change it elsewhere too
to make clear that the variable being
used is the same one by a different name
that's perfectly fine but here's where
we now get into a matter of
of better style having a variable
called just a doesn't make really lends
itself to the readability
of your code i might now glance at my
code and be like what is the variable a
it's a little better when it comes to
writing good code to actually be
more verbose and using an actual word
like answer
in this case indeed even though i keep
describing x and y and z as the go-to
variables for a mathematician those
really say nothing outside the context
of like a cartesian plane
so in a program that you write in c or
scratch or anything else
using descriptive variable names is a
matter of good
style as well uh jonathan over to you
yeah just a quick question how come we
have to compile the code every single
time
um and unlike different ides which if
you just run the code it automatically
compiles
uh why do we have to manually do it yeah
really good question why do you have to
keep recompiling the code
short answer is just because this is the
way c is
um it's an older language decade's now
old and so back then
everything was very deliberate user
interface was not the top priority
performance instead was for instance
and so nowadays there are fancier
integrated development environments and
some of you
might have used things like
codecademyonline or code.org where
there's very often like literally a play
button
that you can just click in the user
interface and it just plays your program
or
runs your program what we're doing in
this class is showing you what those
buttons are doing so if you do use a uni
an environment like that that seems to
automate this it's still happening but
for our purposes certainly at the
beginning of the semester
we're going to do it manually ourselves
later in the term when we introduce a
different language all together for
instance python
then kinda sorta you don't need to
compile
any more but more on that in a few weeks
good question uh sophia
over to you i
had a question about i noticed in the
source code that there's a backslash
like n
at the end of the string is that
necessary for every time even if it's
just one line
really good question this backslash n
that you're seeing elsewhere
a bit of a spoiler but yeah let's go
ahead and fix this problem that we've
seen
even though i'm kind of ignoring it you
know this now gets a little particular
but this looks kind of stupid honestly
it says hello comma brian tilda slash
dollar sign
like that is not my intended output i
literally only wanted to say hello brian
or hello david
this visual artifact here the dollar
sign and the tilde and the slash
have to do with my terminal window this
command line environment that i'm using
and honestly just to be a little
nitpicky frankly it should probably be
on a new line it should just
be on its own line so it's not confused
with my own output
and as sophia notes we there is a
solution to this
but again per last week you need to be
when writing
algorithms and in turn code you have to
be super precise
nowhere in my code have i told the
computer to move the cursor to the next
line
so i can do that explicitly by doing
backslash n immediately after the
percent s but still
inside of the double quotes this is
shorthand notation
for what would be telling the computer
move the cursor to the next line
now you might think that well why don't
i just hit enter like this
and even though this all might be new to
most of us suffice it to say that
this just feels like it's going to get
messy quickly if you start hitting enter
in the middle of your code
that's probably not the right solution
so instead programmers years ago
decided to come up with shorthand
notation like backslash n
otherwise known as an escape character
that sim
uh signals to the computer put a new
line
here so backslash n is newline and let
me go ahead and recompile this
after saving my file let me go ahead and
do make
hello it seems to compile okay dot slash
hello let me go ahead and type in
brian's name again and voila
still the same output but it's a little
cleaner so we're doing a being a little
bit better about housekeeping now
really good question uh uh bj
is it uh yeah so one question i had is
why don't you have to call the function
get string
in order for you for it to ask for input
like it still asked your input when you
assigned it to the variable
answer ah really good question why don't
i have to call getstring for instance by
putting it on a line of its own
the way that c and a lot of programming
languages work
is they will evaluate an entire line of
code for instance what i have here on
line
six uh from right
to left at least in this context when
you have an equal sign
on this in the code like i do here
that's telling the computer
you first have to execute that is do
what is said on the right-hand side
and then whatever the output of that
thing is store it on the left-hand side
so it is indeed getting executed we're
just now
spreading things out on longer lines of
code if you will if that makes sense
so getstring is getting executed
because it appears on that line all
right so
we've been taking for granted frankly a
few details of these programs that it's
probably only fair to start teasing
apart for instance there is that int
main
void and a whole bunch of other syntax
so let's tease apart
some of these other lines of code that i
just typed off the top of my head for
memory
but kind of do need to be there in every
c program you write let's at least start
to make sense of some of that detail
recall that in scratch we always started
our programs initially
with when green flag clicked we
eventually saw some other puzzle pieces
like
when uh you hear an event or when
there's camera motion
but this really kick-started most of the
programs that we wrote in scratch
what is the analog in c of the of the
when green flag clicked publicly piece
it's essentially this we won't spend
time in detail today
explaining why it's int why it's void
why there's curly braces why there's
parentheses
for today's purposes only let me just
stipulate that this is the analog
for this when green flagged clicked
puzzle piece you've just got to start
your programs initially
with this kind of boilerplate code so to
speak we will start to explain this in
much more detail but for now just take
on faith that this is how you start
writing a program
but there's of course a little more to
the programs we've written thus far
and particularly we've seen a couple of
things called header files
this is another term of art that refers
to a pro a file
written in the language called c whose
name ends with not
dot c but with dot h so we've seen these
before
as follows here recall was the simplest
program we wrote last week in scratch it
just says hello world when you clicked
on the green flag
this is the analog the more complete
analog on the right
of that program today but there's
something missing
and it's probably jumping out at some of
you because the program is a little
shorter
than it was before something's missing
which is this line here and i just wrote
that from memory earlier
but it's referring to a file called
stdio.h
which stands for standard input output
dot h so i o is an acronym in the
computer world that just generally
refers to input and output
so standard io.h is just a very
popular file that is used in c programs
that gives you the ability to get input
and output from the user
and it does so by providing you with
printf for instance which of course
allows you to generate some form of
output via those
those side effects that we described
earlier but when i wrote my other
program recall that actually had
get string as bj noted earlier where i
can get a line of text from the user i
needed something else altogether
and that's when we added a moment ago a
second header file called cs50.h
so these header files just give you
access to more
functions than you might automatically
get from the language
you're using which here is c it's
similar in spirit recall last week when
i started poking around scratch's
extensions menu
and i used the translate block and the
the voice block the sort of fancier
features that were buried under the
extensions menu using an extension in
scratch
is similar to using a header file in c
it's giving me access to a bit more
functionality than you otherwise get
for free out of the box so to speak
all right let me pause here to see if
there are any other questions
before we forge ahead to actually create
some problems
uh that you two will likely encounter
and we'll give you tools via which to
solve those problems so that you don't
feel completely
on your own in a new language any
questions brian
before we forge ahead
no all right i'm going to slowly tiptoe
back
until brian gives me the cue all right
well let me go ahead and propose that
there are so many different ways in
which i could have screwed up
over the past few minutes of writing
these programs
uh i might have omitted a semicolon as i
implied i might have not closed my
quotes i might have gotten my
parentheses wrong i might have
misspelled words altogether
there's many different ways i could have
screwed that program up and frankly off
the record i was sort of crossing my
fingers that i didn't screw up
our very first program together but
invariably
at some point maybe not your first
program but early on in learning how to
program or learning how to program in c
you will screw up and you're going to
make some typo there's going to be
some disconnect between what your
understanding is and what you're trying
to get the computer to do
and this is to say there are tools
thankfully that can help you
solve those problems and the first of
which is called help 50. any of the
tools whose names end with 50
are specifically educationally oriented
written by cs50 staff
that are temporary training wheels that
we'll use for the first several weeks of
the class
but then eventually optionally take away
in the sense that you won't need them
anymore and so help50 is one command
that's going to allow you to
troubleshoot
problems that you might not otherwise
see obviously
in your own code and let me go ahead and
simulate this
as follows let me go back to the very
first program that we wrote in c
which was quite simply this one whereby
it only said hello world
and there's a few different places i
could have screwed up here for instance
suppose i was getting a little ahead of
myself
and i omitted the standard io.h file
at the top of my program the implication
is that now
my computer is not going to know what
printf
is because it hasn't been included via
standardio.h so let's see what the error
message is hopefully it'll be a very
self-explanatory message that makes
perfect sense
let me go ahead and recompile this
program knowing it already to be
incorrect
and oh my god like i this i have more
lines of errors than i actually have
lines of code and this is kind of a
neces
well this is kind of a reality of
programming
a lot of programming languages a lot of
tools frankly were not designed with
ease of use in mind or user friendliness
in mind they were really designed with
succinctness and precision in mind and
they tend unfortunately
to assume that the audience is as
technical as the person who wrote the
program
this of course can backfire when you're
just learning how to program in the
first place
and you have to make sense of crazy
cryptic output like this
today we don't have to focus on every
single word that's been output out on
the screen
but let's start to recognize patterns
walking into a new space and just
recognizing familiar objects in the
physical world
let's now do that with code the most
important thing perhaps to take notice
of
is that when you mess up and you make
some mistake in your code such that your
program doesn't even compile from source
code into machine code
odds are you're going to see a clue
toward the top of the erroneous output
that tells you the name of the file
where you messed up and the line number
where you messed up
three implying line three and then five
might imply what
column or what character in that line
but it depends on the particular problem
if that's that useful
so on line three i am getting an error
implicitly declaring library function
printf
would type in const char star i mean
like who knows what that even means
you will eventually but for today it
just means something bad went wrong and
you might not see it
you might not know if i hadn't told you
that i intentionally deleted that line
so let's see if we can't make sense of
this by using this tool help 50 is a
tool written by cs50 staff
that will help translate arcane cryptic
computer messages to more human friendly
advice and questions that your teaching
fellow or teaching assistant
might offer you say in the context of
office hours so to use help 50
instead of running the same command
again and again and seeing the same
erroneous output
literally just write help 50 first at
your terminal window
then write the same exact command that
you're struggling with for whatever
reason
and hit enter then and what will happen
is the same command will get run
we will analyze using the help50 program
what that output is and we'll try to
highlight in yellow
the stuff we recognize and then
translate it to more human friendly
language for instance
after running help50 we're asking for
help dot dot dot
in yellow here is the thing we recognize
oh the staff have seen this problem
before
and then down here did you forget to
include standardio.h
in which printf is declared atop your
file so hopefully
if we recognize the problem we can guide
you with this sort of rhetorical
question that makes you realize oh yes
that's what i did wrong so now i can go
back up here
move to the top of my file and add
include
standardio.h and now notice if i rerun
make hello voila the problem has gone
all together
and we could do this all day long
there's so many places to mess up for
instance i omit the semicolon now
let me go ahead and make hello now
without the semicolon now we're going to
get a different error message
and you'll see again the name of the
file where i messed up hello.c
this time it's on line 5 and that's true
because
the line numbers move down after i added
more stuff up there and you can see
expected semicolon after expression
so this one's a little more
straightforward but you could run help
50 on this command too
just to get back a little more explicit
advice so help50 will be your friend
anytime you are having trouble getting
your code
to actually compile well let me do
something else that's
bad now i've very deliberately been
writing fairly pretty code i've indented
the word printf
i included some blank line up here just
to make it clear i've put these curly
braces so to speak on their own lines
but frankly my computer or cs50 ide
is not so particular i could technically
get rid of this blank line
i could move this curly brace way up
here i could get rid of this indentation
altogether and move it on the
on its own line and then i could just
move this curly brace up here
thereby writing a program that's now
only two lines long
not six but hopefully already even if
you've never programmed before
this should probably rub you the wrong
way this is like people in the real
world that like don't use punctuation in
their social media posts or their emails
or their text messages they just kind of
go on and on and on
and yes the information is there you can
glean what it is they're trying to
communicate but my god is it annoying
it's hard to read there's probably a
higher probability that there's a
mistake and it's going to be harder to
find it because things aren't nicely
balanced
on the left and on the right and on the
top and the bottom so this is what would
be
described as bad style my program is
still correct i've got the standard io.h
i've got the semicolon and everything
else but it's really bad style because
it's just
ugly there's not much white space
there's not a lot of blank lines or
indentations that just make it easier
for you and i
to read this thing from top to bottom so
notice
it does compile so help 50 is not going
to help me fix this problem because it
compiles okay
but i it can run another program that
we're going to call style 50. this is
another educationally oriented tool
that's installed in cs50 ide
that allows you to figure out how to
improve the style of your code
so when i run style 50 we'll see some
output that at first glance might be a
little cryptic
but i think it'll help us make sense of
the program ultimately
to run style 50 you instead run style 50
and then just the name of the file in
this case hello.c so you don't run
make again you don't run make hello you
do style 50
space hello.c i'm going to go ahead and
hit enter
and you'll see some somewhat cryptic
output here but in green highlights
the tool is trying to coax me toward
improving
this file so notice here backslash n
this was noted earlier
that it means move the move the cursor
to the next line
so the fact that this is green here
backslash n that means my gosh
hit enter after this parenthesis the
fact that there's another backslash n
here means hey human
hit the enter key again to move the
curly brace onto its own line
the fact that there's four green spaces
here means a human literally hit the
spacebar four times or hit tab
once to indent your code and then
finally one more new line here so style
50 doesn't fix the code for you
stylistically
but it tries to draw your attention to
all of the possible places
where you can improve this so let me
take it literally let me add a blank
line there
let me add a blank line there let me
indent by four spaces there
and let me move the curly brace down
there and now
i can re-run style 50 on this prettier
code
and hopefully it indeed looks good but
it's still giving me advice
it's telling me to add something called
comments and a bunch of you figured this
out in the world of scratch
you can add little sticky notes or
post-it notes to scratch that are sort
of notes to self that remind you
what something does or maybe explain to
your teaching fellow or teaching
assistant what
something does c supports these as well
so for instance if i just wanted to be
really pedantic here
and make clear to the human reading my
code what i'm trying to do
i could say something like greet user
and notice the syntax here i've put a
new line
above my existing line of code and i've
similarly indented it so everything
lines up
visually beautifully i've done slash
slash
which says hey compiler this is a
comment this is for human eyes only this
is not
actual c code per se then i hit the
space bar and then i just typed out an
english phrase and this could be any
spoken language
but i went ahead and typed greet user
why well it's just a reminder to myself
what the purpose of the following line
of code is is to greet the user
this is marginally better for instance
than saying
print hello world and let me just ask
here even if you've never
programmed before why is the first
comment
of better comments than the second like
why should i say
if anything greet user instead of print
hello world
in the form of these comments brian do
you want to call on
one person's hand here
yeah olivia what do you think
oh you're unmuted in zoom but can't hear
you technically
can you hear me now yes okay it tells
you the purpose of the code
yeah the purpose of the code as opposed
to what what distinction are you making
and versus telling you exactly what it's
doing
yeah exactly if your comment is almost
identical to the actual code
you're not really conveying much more
information to the reader let alone
yourself in the future
explaining it more generally what the
purpose of this line of code is to do is
to greet the user
that's a little more descriptive now to
be super fair honestly this program is
so short
that even though style50 yes would
prefer that you add some comments
if you're lying if your program really
reduces to one line of code you probably
don't need a comment now
here however pretty much every other
program we're going to write here and
after is going to be more than just one
main line of code like this printf
so it's going to make much more sense
soon to come that we're going to want to
actually print out
add to our code some actual comments
well let me introduce one
final tool here that will help us solve
problems as we proceed now to write more
sophisticated
programs and this is check 50. this is a
tool specifically
that you'll use either in labs or in
problem sets the course's programming
assignments
to actually check the correctness of
your code so whereas help 50
just helps you compile your code
typically when it's not compiling at all
style 50 helps you improve the style of
your code check 50
will check the correctness of your code
against
some automated tests that we the staff
have written
that are consistent with whatever the
homework problem
actually is so we write some tests to
make sure that your code is working
correctly
as per our own specifications so how
might i
run check 50 this will totally depend on
the problem set or the lab
and we will always in the problem setter
lab tell you what command to type for
check 50. it's not something you could
necessarily figure out on your own
i happen to remember that we have a
check that is a test
called cs50 slash problems slash hello
and this just happens to be a unique
identifier even though they're slashes
it's not a url
it's not the path of a file it's just a
unique identifier that we will always
tell you
in the problem set or lab if i run this
command now what's going to happen is
the file called hello.c in my ide
is being uploaded to github this popular
place for storing code i'm going to log
in with my student account
and then oh none of you can actually see
what i'm doing here so we're going to
restart this demonstration here
because now you can actually see my code
so made it
almost without a mistake so check 50 is
this tool that's going to allow you to
test the correctness of your code let me
go ahead now and run it as follows i'm
going to type check 50
and then cs50 slash problem slash hello
odds are you will never run this
identical command
again in the problem set or lab we will
always tell you
what to type you won't know what
otherwise to type unless we tell you
what test to use
this is going to now upload my file
hello.c
to a service called github which again
is a popular tool for sharing code we
use it to collect submissions for this
i'm going to then type in my password
you won't see it you'll instead see
asterisks or like bullets in a web page
i'm going to go ahead and hit enter then
it's going to verify my code it's going
to do some thinking
it's uploading now dot dot dot and now
we're just waiting for the internet to
respond because somewhere on cs50
servers
we are running your code after compiling
your code or in this case mine
and making sure yes it actually behaved
as it should have and what you'll
typically see hopefully
are a bunch of green smiley faces saying
yes that your code exists
yes that your code compiles and yes for
instance it prints hello world
sometimes you might see red frowny faces
which means no your code did not work
exactly as it should per the lab or per
the problem set
at which point it's back to the drawing
board on your part to figure out exactly
what needs to be fixed up here
sometimes you'll see yellow output with
just a straight yellow face which just
means we weren't even able to run
a certain test because some other test
already failed so it's meant to be
relatively
quick feedback on the correctness of
your code before you even submit it
and call it a day and check 50
instructions will always be accompanied
by the problem itself in the lab
or problem set so some final commands
here now
within this terminal window i can do
more than just run
make and dot slash hello or whatever my
program's name is
and i can do more than help 50 and style
50 and
check 50. it turns out that i'm really
using in the form of cs50 ide
my own server in the cloud so yes i'm
using a website
but what cs50 ide really is it's like
your own
server or your own computer in the cloud
somewhere out there on the internet
you have your own username and password
in the form of cs50 ide
and only you can access the files that
you write
the programs that you write that are
stored in this ide
and there's a few more features i'll now
draw our attention to perhaps the most
friendly one is this little folder icon
at top left
if i click this little folder icon
you'll now see what's
generally called a file browser or a
file tree which is just like a graphical
representation of the files
in my account or in my ide in this case
looks similar to mac os looks similar to
windows and this is just a graphical
user interface built into the ide
so that for instance if i close my tab
by clicking this little x button up here
and i want to reopen the file much like
you would imagine on a mac or pc
it's as simple as double-clicking the
file on the left-hand side
but notice i didn't click on hello
because notice what happens if i open
hello my gosh
like what is going on here
this is kind of a mess there's redness
there's dots
any thoughts from someone on why
i'm seeing what i'm seeing because odds
are you will accidentally at some point
click on a file like hello
instead of on a file like hello.c
sarah what do you think
it is the binary code so it's the
machine language so it doesn't allow the
user to see them besides the code they
write and see
yeah exactly what you're trying to look
at in this tab
is binary codes zeros and ones however
those zeros and ones are technically
being misinterpreted at the moment
as ascii characters or unicode
characters so recall from last week
ascii is this mapping between numbers
and letters
and numbers of course are just patterns
of zeros and ones and this looks super
cryptic because we're trying to
misinterpret zeros and ones as though
they're ascii characters and recall that
there's
many more characters in ascii and
unicode than a
through z and the numbers there's some
unprintable characters
and indeed all the funkiness we're
seeing here is just a misinterpretation
of zeros and ones
that are instructions to the computer
machine code
for the computer being misinterpreted as
text so you can't edit a binary file
like this so to speak
you should just close hello when you do
something like that and make sure you've
double clicked on and opened
your actual source code file as well
so we've seen strings and there's other
data types and there's other functions
and there's loops and conditions and so
much more
i think we're at a good point now to
perhaps take a break let this sink in
why don't we go ahead and take a seven
minute break
and when we resume we'll introduce a few
more features of c and compare them
against what we saw last week
in scratch so we'll see you in seven
minutes
all right we are back so recall where we
left off was we were looking at this
graphical user interface the top left
the file browser the file tree that just
gives us more graphical
access to the files in our account but
let's now
do this the the old school command
line way in my terminal window so it
turns out that using our terminal window
can we not only compile code and run
code and run check 50 style 50 help 50
and the like
we can also manipulate files and folders
even that happen to exist
in my ide that is in the computer i have
access to here in the cloud
and the first command i'll propose is
that we type ls
ls is shorthand notation for list and
quite simply ls
lists the files or folders in your
current folder
so this would be like double clicking on
your my documents folder in windows or
documents in mac os
ls just lists the contents now notice
hello is a little weird it's highlighted
in green and there's an asterisk
and there's an asterisk after it and
that's just a visual cue
that that file is executable that is
that is a program that you can run with
dot slash
hello the star is not part of the file
name and of course we see hello.c
now suppose that i wanted to maybe
rename
my file well i could much like in mac os
or windows i could go up to the file
browser up here
i could control click or right click and
notice there's a whole bunch of menu
options that pop up just like on your
own computer
and i could rename the file right up
here but generally speaking we're going
to do things at the command line only
because rudimentary as some of these
operations today
are it's going to be a much more
powerful command line interface for me
so suppose i change my mind and
you know what i i don't like this
version of hello i want to delete that
program
and start over strictly speaking i don't
need to delete hello ever i can just
recompile it and it will keep getting
changed and changed but if i do want to
remove it i can type rm
hello and then hit enter and then i'll
be asked remove regular file hello
that's just a visual confirmation that i
do indeed want to delete and i can type
y
or yes or some such reply and if i hit y
and enter nothing seems to happen but
notice what happened up here at top
left notice that hello is now gone
leaving only hello.c
and if i type ls again now i see only my
code file
maybe now i want to change this program
and i don't want to write hello.c but
goodbye.c
well let me close the tab up there and
yes i could go and right click or
control click on it but again we don't
need to use the graphical interface
let me go ahead and instead do mv
hello.c
goodbye.c mv is the move command
and even though it would be nice if it's
called rename instead of move
move just moves one file to another
location or to another name so if i do
move
hello.c goodbye.c notice what happened
at top left
now my same file is called goodbye.c and
if again i type
ls i can see that it's indeed uh
renamed now let me go ahead and move
that back because i want to stay
on my hello.c program but suppose i want
to start organizing my files in a moment
we're going to start writing more
programs
and so my account is going to get a
little bit messy with more and more
files over the course of today
so suppose you want to create a folder
otherwise known as a directory
i'm going to go ahead and type mkdir for
make
directory and then the name of the
directory i want to make for instance
lecture you could call it anything you
want but if i'm in lecture i'm writing
code
maybe i want to store all of today's
files in a lecture directory
when i hit enter there notice what
happens in my file tree up here
i now see a lecture folder if i click
the triangle
it's empty because i haven't put
anything in it so let me go ahead and
move
hello.c into the lecture folder mv
hello.c lecture and now let me hit enter
and voila now notice that it's nested
inside of this lecture folder
and indeed if i now type ls for list i
only see the lecture folder
unfortunately i'm kind of now don't have
access to hello.c
within this command line environment
unless i change into that directory now
in the world of macs and pcs
we obviously would just double click on
a folder and voila we're inside of it
in a command line interface you need to
be more deliberate so i'm going to do cd
for change directory then lecture and
then i'm going to go ahead and hit enter
and now notice and now it might make
more sense why this whole time we've
been seeing in blue
this tilde lecture slash the tilde just
means my so-called home directory like
my
own account my own default folder like
my documents and windows or documents on
mac os
that's what tilde represents in
shorthand notation lecture is the name
of the folder
that i am now inside so it's as though i
double-clicked on lecture in mac os or
windows to open a folder
now i'm inside this lecture directory in
my terminal window
so if i now type ls enter i should see
voila
the hello.c file that was in front that
was uh
that i moved into it now let me undo
this because i'm going to go ahead and
keep things a little simpler for now
and suppose that i want to move hello.c
into where it previously was last piece
of syntax
there's this shorthand notation for what
we'll call a parent folder
so just like in family trees there's the
notion of parents and children
and grandchildren and so forth that's
also true on computer systems that have
folders and folders inside of folders
and folders inside of folders inside of
folders
there's a hierarchy there much like a
family tree so if i want to move hello.c
one level up i can actually do mv
hello dot c space dot dot and that's
like saying
move this file to the folder up above
when i do that
notice what happened at top left now
hello.c
is not inside of the lecture folder but
below it and indeed if i type ls
now in the lecture folder there's
nothing there how do i move myself
up one level in the family tree that are
these folders
let me go ahead and type cd space dot
dot
so change directory to my parent dot dot
just means your parent the folder up
above
enter and now i'm apparently in just
tilda slash which is again
cryptic shorthand notation for your own
home directory your my documents
or documents folder and if lastly i type
ls here
i'm done with this lecture folder i
don't want to bother storing things in a
folder
i can do not rm for remove like uh
i did to get rid of hello but rmdir
to remove a directory and voila it's
gone
and i've undone all of the various
changes that i made earlier
but perhaps now it makes a little more
sense why i was doing something earlier
let me open up my hello.c file
let me make hello again which is way
back where we left off
and recall that all this time i've been
doing dot slash hello
well why is that well just as dot dot
refers to your parent directory a single
dot
refers to your current directory so even
though this looks a little silly
dot slash hello is just a very explicit
way
of telling the computer run the program
called hello
that's right here in my current
directory dot means current directory
dot dot means parent directory and so
there we see finally
why i've been typing dot slash hello all
this time but again it's just the
textual analog
of doing something like uh double
clicking on an icon in mac os
or windows so there's other commands too
and over time you'll get exposed to
these and use them for various problems
cp for copy for instance uh is yet
another and many others but these are
all just standard commands they are not
cs50 specific
standard commands that allow us to
manipulate files and folders
in a computer like this and question
from max
uh hi yeah sorry i was just wondering i
don't really understand the difference
between the hello
program and the hello.c program it seems
like the one that doesn't have
c on it isn't used for anything or oh it
is though so recall that we have two
things
in the story we have source code which
is the c code i've been writing
and then machine code which is the zeros
and ones that the computer understands
i have been writing all of my code in
the file called hello.c
but after i compile it with make the
make
program creates a new file called hello
that technically contains only zeros and
ones and that is the machine code that
i'm actually running
when i do dot slash hello so again i can
use
rm and i can get rid of the hello
program just like i did before
and now we're back at the very beginning
of the story where we wrote this code
from scratch
if i now type make and let me do this
now ls notice i've only got one file
let me now do make hello i see that
cryptic output but if i type ls again
now i have two files and that's because
only
the green one with the asterisk is
executable that is the machine code that
the compiler
has created for me and i should say and
disclaim i've been telling a little bit
of a white lie today
make itself is not actually a compiler
we'll see next week exactly what make is
doing
but it's making it easier for us to
actually compile our code
but more on that next time all right
so we've seen only strings thus far but
it turns out in c and in a lot of
languages there's other things known as
types or data types that is to say you
can have variables and values
that aren't just strings of text but
that are maybe integers like numbers one
two three four
or maybe floating point values like
3.14159 or other such values
you can have boolean values which are
only true
or false you can have characters or
chars
which are single characters this is to
say within a language
like c there's actually a whole bunch of
data types that are available to you
string is only one of them and there's
even more than are on this list here
but this is just a list of some of the
most common ones that we'll see today
and will use this coming week in the
first problem set
that allow you to tell the computer not
only to store a value in a variable
but what type of value to store in a
variable moreover
we have in the cs50 library a whole
bunch more functions we've seen
getstring already
but similarly have we created functions
that you can use for problem sets labs
and beyond
that allow you to get a single character
by a getchar
that can allow you to get an integer via
getint that can allow you to get a
floating point value which is a fancy
way of describing a real number with a
decimal point
using get float but it turns out that
each of these data types
like int and float only have a finite
number of bits
and recall from last week that we played
around with light bulbs and we played
around with bits and zeros and ones more
generally it turns out that
every one of these data types char
double
uh float int long string and so forth
all use a specific number of bits and it
turns out
that ins for instance integers in c only
use
32 bits and that's great until such time
as you want to count higher than roughly
4 billion at which point you can't we'll
see later today that
if you're only using a specific number
of bits you can only count so high and
so there exist other data types for
instance a long
a long is another type of number in c
that just uses 64 bits so it gives you
way more expressiveness way more
patterns of zeros and ones to count even
higher
similarly a double is like a floating
point value a real number with a decimal
point and some number of digits after it
a double allows you to have even more
digits
after it then a float would so we'll see
and use some of these data types
in just a bit printf similarly has the
ability to print out not only strings as
we saw
but also using different format codes
other data types as well these are a
little more cryptic and it's fine to
look these things up as needed but
you'll
eventually ingrain them for common use
cases
percent c is going to be the placeholder
for printing a single character percent
c for a char
so to speak percent f is going to be for
a floating point value so if you want to
print out a real number with a decimal
point you're going to use percent f
if you want to print an integer using
printf you're going to use percent i for
integer
if you want to print a string we've
already seen percent s and if you want
to print a long
integer aka long you're going to use
percent li
and there's even others but these are
perhaps some of the most common and it
just means that again
c really needs you the programmer to be
precise you can't just say print this
you have to tell printf how to print the
variable or the value
that you're passing into it and then
lastly it turns out that in c
there's a whole bunch of operators
certainly mathematical ones and bunches
of others as well just like scratch had
a whole toolkit
of operators and suffice it to say for
now that c
also supports addition subtraction
multiplication division
and even the remainder operator which a
little cryptically is represented with a
percent sign
not to be confused with printf's format
codes but this is to say that some of
the earliest uses of computers of course
were all mathematically oriented in
spreadsheet programs programs like visit
calc and the like
back before there was excel in google
spreadsheets and they certainly
computers are very good
at supporting math and so these are just
some of the operators that we'll now see
are available to us so let me go ahead
and do this let me go back to
my ide after cleaning things up
and starting fresh with just nothing in
my terminal window and no tabs open
and let me go ahead and write my next
program this time using some more of
these functions
i'm going to go ahead and create a file
up here called
edition.c so edition.c but i could call
this anything i want but it's important
to add the dot c
otherwise the computer will not know
that it's actual source code as opposed
to machine code
and let me go ahead and make use of the
cs50 library so let me include cs50.h
let me include standardio.h so that i
can use things like
getint and printf and then again for
today's purposes i'm just going to do in
main intmane void and then the
curly braces and again for today just
take on faith this is necessary but
we'll explain within a week or two
exactly why we keep writing int main
void but for now it's like the when
green flag clicked
puzzle piece let me go ahead now and get
an integer from the user suppose my goal
now is not to write a program that gets
a string of text and prints out hello
brian or hello david
let me go ahead and write a program that
maybe asks for two integers two numbers
and then just adds them together so let
me make the simplest of calculators
using code
well i'm gonna go ahead and declare a
variable
called x just like a mathematician would
and i'm gonna assign it the value
of calling get int and i'll just say
something like
x colon i could say anything i want what
is x question mark but i'm going to keep
it simple and just say x colon
semicolon to end my thought so again
similar in spirit to what i did with
string before
but now i'm using get int to get a
number or an integer from the user
the quoted parameter here or argument
is the input to print to getint which is
going to be the prompt that the human
sees
the equal sign recall is the assignment
operator which says
copy the return value on the right
the integer that the human hopefully
will type in over to the left
and the left says give me a variable
called x
and let me store integers in it
so before we used string on the left and
we used get string on the right the only
difference now is
int on the left because i want a number
and get int on the right
then let me go ahead and do this again
and get another number
get int and i'll just say y colon but
again i could say what is y
question mark or anything in english but
the last line is going to be the
interesting one
now i'm going to go ahead and print out
for instance the sum of these two
numbers
but printf again takes an input that
tells it
what to print out exactly so i can't
really type a number here yet because i
don't know what the human is going to
type in
so i'm going to put a placeholder i'm
going to put percent i
which says put a number here i just
don't know yet what it is
and then just to keep things clean i'm
going to do backslash n which just says
give me a new line also that's just an
aesthetic detail to move the cursor to
the next line just to keep things
clean but now printf is going to take a
second argument
and whether you've programmed or not
before brian let's go to someone in the
audience if we could
what should i type after the comma if
the purpose of this program is quite
simply
to add two numbers together even if
you've never programmed before
based on the operators that exist and
some of the syntax we've seen thus far
what would your instincts have you type
here even if you've never
done this before santiago what do you
think
um i would say to just write x plus y
yeah it is as simple and as
straightforward as that x plus y is the
right intuition i'm going to add a
semicolon at the very end just to finish
my thought but indeed computers
and c in this case absolutely understand
arithmetic and mathematical operations
so just type what you mean
i'm going to go ahead now and save the
file and go down below and i'm not going
to type make hello anymore now i want to
type
make addition because that is the name
of my file implicitly
edition.c i want to compile into a
program called edition
hopefully this is where i cross my
fingers i didn't make any mistakes
and i'm going to go ahead and run make
addition
all is well no error messages if i had
made a mistake and it didn't even
compile
help 50 might have been my next instinct
now i'm going to go ahead and run dot
slash edition
and notice i'm first prompted for x i'm
going to go ahead and do one
i'm next prompted for y i'm going to go
ahead and do one again
and voila santiago proposed i indeed see
on the screen
x plus y or the value 2. and i didn't
hard code 2
i substitute it in using percent i
whatever the result of
x plus y actually is now notice
some of the features of the get in
function for you suppose that you're not
being very cooperative and you type in
cat for x notice that get in just
ignores you and prompts you again
if i type in dog it ignores me and
prompts me
again if i type in 1.23 it ignores me
and prompts me again because it wants an
integer in this case a number like one
two three four or negative one two three
four or zero
or anything above or below so fine i'll
cooperate now and give it the number one
same for y it's going to ignore any
non-integer input so if i give it a
number like 2 this time i'll hopefully
get the answer of
3. all right so we have a basic
calculator in c
we're using some basic building blocks
as before we've got these header files
which just give me access
to getint and printf respectively but
suppose now i want to count up even
higher you know what let me try
something like this let me run this
program once more
and let me get a little greedy how about
four zero zero zero
zero zero zero zero zero zero so roughly
four well exactly
four billion uh that's the number i want
to type in
notice that x does not like that so get
in does not accept four billion well let
me try maybe three billion
uh-huh didn't like that how about 2
billion
okay that one worked let me pause here
what's going on perhaps now again we
the staff wrote get in so we are the
ones that are rejecting
cats and rejecting dogs and rejecting 4
billion and even 3 billion
but in this case it's a little less
clear why did we reject 4 billion in 3
billion do you think
based on some of the definitions thus
far today
why might this be nathaniel what do you
think
hi um i just got unmuted uh there's like
a cap on like the size of the number
since um it would take too many bits and
bytes uh after the size of two billion
perfect so integers again are
implemented in c as these things called
ants
ants only use it turns out 32 bits total
and you you would only know that by
having been taught it or looked it up
for a particular computer system
but they on cs50 ide and most modern
systems an integer
is only 32 bits and that then invites
the question well if you've got 32 bits
or light bulbs how high can you count
well it turns out with 32 light bulbs or
bits you can count
roughly as high as 4 billion you can
absolutely count as high as 3 billion
and yet get into still rejecting it but
that's because the get in function
supports integers broadly speaking which
includes not only
positive numbers but also negative
numbers
and zero and the catch is that if you
want to support both positive numbers
and negative numbers
you can represent four billion or so
total possible values
but if you want to go as far to the left
and as far to the right on the number
line that i'm describing
you can only really count as high as 2
billion in the positive direction
and negative 2 billion in the negative
direction because that still gives you a
total of 4 billion
but not nearly as high as 3 billion or 4
billion so what might the solution here
be
well i recall earlier noting that
there's other data types not just ins
and strings but also
longs which literally are longer
integers namely 64 bits so let me go
ahead and try this
let me go ahead and change get in to get
long this get in
to get long let me change this in to a
long
and this into a long so same program
same calculator but i'm now using a
different data type
that's just going to use more bits to
store values let me run
make addition again to recompile my
program and oh
damn it i screwed up so let's see if we
can't glean what's wrong here
let me scroll up and i can't emphasize
this enough sometimes i got lucky here
and i only have one mistake
apparently in the error messages it is
not going to be
uncommon for you to have two errors 10
errors
in like two lines of code this is
because sometimes when you have errors
in your code
the compiler sometimes just gets
confused and if it gets sufficiently
confused it starts thinking
everything is an error in your actual
code so the most important takeaway is
that no matter how many errors you seem
to have
always scroll up to the top of the
output and address the first error first
so that's why i scrolled up in my window
to look immediately below what i typed
make addition and here's the first error
edition.c on line 10. all right i can't
see line 10 so let me scroll my code up
and it saying something about format
specifies type int
but the argument has type long we
haven't seen this error before but i
think i can infer from this it's not
super cryptic even though it's
unfamiliar i think what this means is
that
percent i recall was for integers i
think what i need
is a different format code for long
integers which is going to be
l i instead and that was from my little
cheat sheet earlier
so let me go ahead and try this again
make addition after changing the i to an
li
that indeed works now let me do uh
whoops typo
now let me do dot slash addition and now
i'll type in four
zero zero zero zero zero zero zero zero
zero four billion
now get long is happy and it will accept
such a long
integer because it has enough bits
all right questions on types
like ins and longs or functions like get
int
or get long yeah uh peter
yeah uh when i typed uh
two billion and both were integers uh
well eventually it just gives you the
wrong answer
some negative number is that because of
the bits and bytes indeed it's the same
answer so i didn't demonstrate that but
if you inputted both 2 billion for x
and 2 billion for y and then you tried
to add those together
that would require that would give you
mathematically 4 billion but again
an int is not big enough to store 4
billion
if we want to also be able to represent
negative numbers so peter what you're
seeing
is that you can't fit the result
in the data type allowed and we'll see
in a moment uh in a little bit today
actually what the ramifications of that
are but the symptom you're describing is
exactly that
you tried to cram too big of a number
into finitely many bits
32 you can avoid that problem though of
course by switching over
to long let me try one other thing
that's a bit curious let me go ahead and
write a slightly different program now
and i'm going to describe this as
truncation.c fancy term but we'll see
what this means in just a moment
i'm going to give myself at the top
cs50.h and i'm going to give myself
standardio.h
and it's certainly fine once you get
started with the first lab or problem
set if it takes you much longer to type
some of these things out
i'm just doing it for muscle memory int
main void
and now we're good to go with a new
program in a file called truncation.c
i'm going to go ahead and prompt the
user for an int again so
just like before i'm going to prompt the
user for another int
just like before and then i'm going to
go ahead and
do this i want to do division this time
so not just addition that was a little
too easy let me do division so
let me give myself another variable z
equals
x divided by y and let me pause here for
a moment and just ask the question
what data type should i perhaps use for
z
this line of code is not yet correct
because recall that anytime you create a
new variable
on the left here i'm going to need to
put something
to the left of that variable's name so
that c knows what type of variable i
want and thus far we've seen string and
and long so would you propose we use one
of those or something else for z
what should the data type be for z would
you say
data type for z how about jack what do
you think
uh would it be a float yeah so float so
float which is short for floating point
value
which is the programmer's way of
describing a real number let me go ahead
and do that a float and
uh i'm guessing uh your instincts for
float were that well if you
add in type in one number for x and
another for y and the result is a
fraction of some sort
so something with a decimal point we
need to store it in a float so that we
can actually
uh store whatever the numbers are after
the decimal point so let's go ahead and
do this
let me now go ahead and print this out
percent f
backslash n because i'm printing a float
this time and then let me go ahead and
print out
the value of z and you know what just
for good measure let me start practicing
good style here too
so get a number from user let me give
myself another comment get
another number from user or you know
what this seems a little silly
i can combine these lines and why don't
i just say get for instance numbers from
user that's a reasonable way to comment
your code
and then let's just go ahead and divide
x
by y but even this is getting a little
pedantic because you can kind of read
that from the code so at some point we
might not even need a comment for that
so let's just simplify as such let's go
ahead now and compile this
make come on make truncation
all right it compiles okay and i like
how we used a float here that does feel
correct so let me run truncation
and let me go ahead and type in for
instance 4 for x
and 2 for y okay i like that it's 2.000
so that's the correct math
calculation how about 1 divided by 2. so
x is 1
y is 2 and it's 0.0000
all right well maybe that was just a
fluke let me try running it again how
about
uh how about two thirds two divided by
three huh that's not right
either all right how about four thirds
let's put a bigger number for the four
for the x so
four thirds okay it's closer
to right but this is a example this week
of a
bug so my code compiles so syntactically
it's fine
but this is a logical bug like i've
somehow used c code improperly so what
might be going on
here y is one divided by two and two
divided by three both apparently
zero followed by zero six zeroes after
the decimal point and even four
thirds gives me 1.00000
instead of 1.33333
nina what do you think
because with and they don't like
recognize like decimals so
like so fourth four thirds question
three only goes into four one
time so it returns a one and you need to
use like
other types of character like a float or
a double
if you want like the actual decimal yeah
exactly this one's more subtle than the
mistakes i've made before but
c like most programming languages is
going to take you literally
so if on the right hand side of this
expression on line 11
i am literally doing x divided by y
you first have to ask yourself well what
is the type of x
what is the type of y if they are both
ants
by definition of how c works you are
going to get back
an integer as your answer so if you do 1
divided by 2
yes mathematically that's 0.5
0 0 0 0 however if you convert that to
an
int insofar as x and y are ins the way c
works
is it truncates everything after the
decimal point so it does the math
correctly
but because you cannot fit floating
point values you cannot fit decimal
points
and numbers thereafter in an integer you
get you lose
all of those digits after the decimal
point because you can only fit
the integer part of the answer into an
integer
it's not relevant that i'm saving the
results ultimately in a float because
that's too late
the math has already been done on the
right hand side and so yes i'm storing
an integer in a float so i can print it
as a float but it's too late everything
after the decimal point has already been
thrown
away so what are the implications of
this or how could i fix well
i could go through and just change all
of this right like well if the problem
is that x and y are ints well let me
just change them to floats and change
this up here
change x to a float change y to a float
and so forth
that would fix the problem but that's
kind of a heavy-handed solution to this
problem go through and change all of
your code
you can instead be a little more clever
and you can convince
the computer to convert an integer to a
float
by something known as casting so i can
actually go in here
and using a new syntax i can say float y
and i can even for good measure but it's
not strictly necessary also do it to x
you can and c cast or type
cast one data type to another by
literally in parentheses just putting
the new data type that you want
and if it makes mathematical sense for
one to be converted
into the other the computer will do it
for you so in this way
i'm telling the computer convert x to a
float convert
y to a float then do the math and so
before when i typed in 1
and 2 respectively for x and y now it's
kind of like i typed in 1.0
and 2.0 and 1.0 divided by 2.0
is going to be mathematically 0.5
but because x and y now were converted
in advanced to floats
the answer is going to remain a float
0.5
and that's what's going to get stored in
z and ultimately printed
so if i rerun truncation having now
fixed this problem
let me do dot slash truncation type in 1
type in 2. i don't have to type the
point 0 myself the computer is doing
that for me but via these
casts in parentheses now i see that the
answer is indeed
0.5 all right
so we seem to have now some very basic
low-level control
over what you can do with the program
let's now add back all of the fancy
features that we had from scratch last
week so we can start making
more interesting programs so variables
in another term of art called syntactic
sugar
is also amongst these features here so
recall from last week
when we wanted to have a variable called
counter set equal to zero
we can go ahead and define it like this
in c starting today
we're going to instead say something
like counter equals zero
but we additionally need to specify the
data type of that variable
and we need to end our thought with a
semicolon so whereas we said set counter
to zero like this last week
now it's going to translate quite simply
to this on the right hand side
well what comes after that well if we
wanted to increment a counter variable
last week by one
adding one to it we used quite simply
this puzzle piece this week we need to
be a little more
explicit and say something like this
counter equals counter plus one
and semicolon to finish the thought now
this might seem very
mathematically paradoxical like how can
counter
equal counter plus one like that just
doesn't
work logically but that's not the equal
sign in this case
in c as with other languages we'll
encounter the equal sign is the
assignment operator from right
to left so this is saying take counter
plus 1
and store that mathematical result on
the left
so whatever counter is add one store the
result
in counter thereafter effectively
increasing its total by one
now this is a very common operation in
programs we'll see over the term where
you just want to add something up
because you want to keep track
of the count of something so it turns
out there's some syntactic
sugar which means there's a different
way of doing this syntactically
that doesn't give you any new
capabilities that you didn't already
have in c
it just makes it marginally more
pleasant or quicker to type
so this line of code in c is identical
to saying this
line of code in c counter plus equals
one
semicolon means take the variable on the
left and just add one to it
and it's slightly more succinct and it
just makes your code a little more
readable because it's just
fewer things for us humans to have to
read but you can even do one step
further
additional syntactic sugar exists
whereby you don't even need to type this
you can instead just do counter plus
plus counter plus plus is the shortest
hand notation in c
for just adding one to a variable
all right besides variables what else do
we have in our toolkit as of last week
what we also had in our toolkit last
week
the notion of course of conditions a
condition was like a fork in the road
that could allow you to do this thing
this other thing or or something else
altogether
in scratch for instance if we wanted
last week to compare two variables
x and y for inequality is x less than y
and if so say x is less than y how can
we translate this to c
well the syntax is going to be quite
simply this a little new
some new stuff some more parentheses
some more curly braces
but it kind of visually looks the same
albeit in text form
i literally say if a space then in
parentheses i include my boolean
expression
recall those from last week x less than
y is my boolean expression
then notice i use an open curly brace
and a closed curly brace and then i'm
just leaving a blank
line for one or more lines of code just
like i might have
last week and in fact let's put the
equivalent line of code here
print out using printf x is less than y
backslash n so we've already done that
translation before
say is just like printf just like if now
is like if
strictly speaking especially if you've
programmed before you do not need
these two curly braces if you only have
one line of code
inside of the condition however
stylistically for cs50
and for style 50 sake always include
these curly braces nonetheless
and on their own lines all right what
else can we do in scratch recall that we
can do if
else and we can go either one way in the
fork or the other way
in the fork in c the corresponding code
is going to look like this so it's
almost the same as before
i've just added else and then another
curly brace and a closed curly brace
and let me just add in the printfs and
you can see that in c this is really
like the black and white the text-based
version of
what was very graphical last week but
the idea is the same you just got to
start to recognize where the parentheses
go where the curly braces go the
semicolons and all that
sort of visual stuff all right let's
make one more
scratch and uh comparison here was one
where i said if x is less than y
say x is less than y else if x is
greater than y
say x is greater than y else if x equals
y
then say x equal to y now here's where
scratch and c
diverge because scratch is meant to be
very user friendly and not require long
explanations of assignment operators
mit for scratch just use the equal sign
for
assignment c uses the equals on
uh no sorry rewind mit
used the equal sign for equality whereas
c
uses the equal sign for assignment from
left to right but this means equality
as before all right now notice the
difference here
everything is a line-by-line translation
although we can put elsif on the same
line and else if on the same line
except here's kind of a stupid work
around right in some sense humans
decades ago realized oh shoot at one
point
we've already used the equal sign for
assignment what do we use now for
equality
well mit ignored that problem and just
used a single equal sign for equality
computer scientists inventing c and
subsequent languages
when comparing two values on the left
and right for equality
use two equal signs just because one
equal sign is assignment from right to
left
two equal signs is equality comparisons
are these two values equal
but you know what this is not
necessarily well designed
it is correct logically both my scratch
code and my c code is correct
but can anyone make an observation as to
why
the code is not necessarily well
designed i'm doing
a little more work than i need to i
could tighten this code up a little bit
i could type slightly fewer characters
and accomplish the same
correct decision making
any thoughts on in what sense this code
is not
perfectly designed uh great
over to you
yes so you used elsif
two times you could have used else in
the end
without the condition really good
observation i'm using elsif twice which
logically is fine this code is correct
it's asking and answering the right
questions
but consider this if x is less than y is
one fork in the possibility one fork in
the road
else if x greater than y is the second
what's the only other possibility
logically in the world of math
either it's less than or greater than or
equal to
there's no reason to belabor the point
and ask that third question
explicitly let's simplify the code and
marginally better design it as
this just get rid of the else if as you
propose
which isn't that much cleaner isn't that
much shorter but it does avoid asking an
additional question so instead
of maybe three questions being asked now
there's only two and frankly if you're
writing a lot of code or doing this
again and again and again
that kind of difference might very well
add up and indeed give us
now some better code so now that i have
the ability to
use these conditions let's actually try
converting this into a program let me go
ahead and open up a program that i wrote
in advance
let me go ahead and copy a file that i
came with today
called conditions.c and this is one of
the files available on the course's
website let me just open this if only
because it's kind of an
uh literal translation translation of
the scratch code to see
so i've added my include files at the
top here
i've and now let me show you what i've
actually done over here
so i've opened up a file that i wrote in
advance called conditions.c
and i have at the top of the file my two
includes as usual
and then down here i have pretty much
what we just saw on the slide plus
two calls or uses of get ins
and then i'm just asking this question
down here if x less than y
else if x greater than y else go ahead
and do the following
so it's just a copy paste pretty much of
the scratch
translation let me go ahead and make
conditions which again conditions.c is
the name of the file
no apparent mistakes so let me go ahead
and run dot slash conditions
enter and x will be 1 y is 2 and indeed
x is less than y if i go ahead and run
this this time for instance with
how about 10 and 5 x is greater than y
and then lastly if i go ahead and run
this with 4 and 4
x is equal to y so i now have a c
program that is actually adding
conditions for me
which is uh adding conditions for me
which is actually then allowing me to
make
decisions and print out one thing
potentially
or the other but let me do something
slightly fancier
let me go ahead and open up another pro
actually let me write this program from
scratch
suppose i want to write a program called
agree.c
that simulates the idea of like these
stupid forms that you have to agree to
when signing into
when using a piece of software for the
first time or the like or even when i
deleted a file before i had to type in
yes or why
in order to proceed let me go ahead and
include cs50.h at the top
let me go ahead and include standardio.h
at the top and then my int main void
which is copy paste from before
and now let me do this let me go ahead
and get not an int from the user and not
even a word let's keep it simple and
just ask the user for
y or n for yes or no let me go ahead and
give myself a char
and i'll call it c but i could call it
anything like answer
but c seems reasonable if i only have
one char let me go ahead and call the
function
getchar and let me just ask do you agree
question mark and then let me go ahead
and compare this so if c
equals y then
let me go ahead and print out agreed
backslash n
else if c equals n
let me go ahead and print out for
instance
not agreed now unfortunately i've made a
couple of mistakes here that one at
least one of which might be a little
more obvious than the other
any thoughts on what mistakes or bugs i
might have introduced
already into this program
any thoughts on bugs here
what do i seem to have done wrong
anyone at all yeah how about uh olivia
what do you think
thank you oh here we go um for one thing
the
for the boolean you did you used a
single equal sign instead of the double
for both good so i use the single equal
sign instead of double so i need to fix
that
and there's another even more subtle bug
and this is because c
is very uh specific when it comes to its
data types
all this time i've been using double
quotes for strings but it turns out
in c you have to use single quotes when
you're comparing individual characters
so i'm going to go in here
and change only the quotes around why
and n to be single quotes why
because i'm now dealing with the world
of chars chars are
individual characters like y or n and
when you are
talking about characters you need to
quote them literally like this
the variable name c doesn't need to be
quoted but y and n do need to be quoted
but i don't need to change any of my
other quotes in the file
because those are still strings of text
that is actual phrases or
sentences so let me go ahead and try
running make agree
it compiles okay let me go ahead and run
dot slash agree
do i agree let me go ahead and type in y
agreed i like that so let me try
n no not agreed oh and i left off
a backslash n so let me fix that real
quick just for consistency
let me recompile my program and pretend
that never happened but let me very
reasonably now do this
dot slash agree i want to agree and yes
capital y
huh nothing happened what about n
capital n
nothing happened but the program still
works if i do lower case it works
and if i do lower case there it works so
what's going on well again the computer
is only going to take you literally and
even though we humans might be oh it's
fine it's uppercase or a lowercase
you have to be more explicit so we can
ask
two questions as follows we could do
something like else if c
equals equals capital y in single quotes
you could imagine again saying agreed
like this
but just like last week when i started
copying and pasting scratch blocks like
that's probably not very good design
similarly this block of code lines 11
through 14 is almost identical
to 7 through 10. let's just get rid of
one of them
and let's see if we can't combine these
thoughts let me express if c
equals equals y or c equals equals
capital y
and indeed you can use this vertical bar
operator
which is the logical or operator and
actually say
two questions at once it turns out you
can do this with the notion of and
a logical and by using ampersand
ampersand more on those another time
but two vertical bars is the equivalent
of just saying if this
on the left or this on the right and now
if i save and recompile
the program with make agree and do dot
slash agree
you'll see that i can type in y in
lowercase
or y in uppercase and now it works
so again it would have been correct to
just add another elsif and another else
if but again
not necessary because i can combine
these thoughts and make my program
better designed and notice too all this
time i've been very
religiously indenting every time i'm
inside of curly braces
indenting every time i have an if
condition or an elf
if so i'm manifesting hopefully good
style
aesthetics as well all right well now
let's consider
that we have the ability not only to
express conditions but how about also
these things called loops well turns out
in scratch we had very straightforward
loops do the following forever
c is a little clunkier there's no
forever keyword in c
but we can mimic this idea as follows
the closest way to translate forever in
c
is actually to say while which kind of
has the right semantics in english like
while something is the case do this
but you have to be even more explicit
you can't just say while
and then say printf hello world it turns
out in c that
while similar to a condition is
constantly asking a question to decide
whether or not to continue very similar
again to a condition with its own
boolean expression
so with while in c you have to have
parentheses after the word while
and you have to ask a question in those
parentheses you have to say something
like
x greater than y x less than y or the
like
but this is a bit of a corner case in
the sense that if you want to do
something forever who cares what the
question is you just want the answer
always to be yes or in computer terms
always to be true and the most blunt way
to express
true always is literally to write the
word true
so even though this looks a little weird
this in c is how you deliberately induce
what we'll call an infinite loop that
never stops
because the true is always by definition
true
you don't even have to ask a more
complicated question you could put a
less than sign or greater than sign or
the like
but if you just want something to happen
forever this is the most canonical way
to express something forever well what
if you want to do something
finitely many times well we can do that
in c as well
using what's going to be called a for
loop uh or a
while loop well let's consider both of
these uh in turn
so if i want to do something 50 times
the most like
mechanical manual way i can think of is
like just count on my fingers right like
one two three all the way up to 50
somehow or 10
minimally on my or maximally on my hands
so how can i do something finitely many
times in c
well i have at my disposal variable so
let me give myself a variable called
counter
initialize it to zero semicolon and the
data type will be int because i just
need to count much like on my fingers
but you know what counter is a little
verbose programmers whenever they're
counting frequently
just counting up from zero on up they'll
often just use i
for integer or c for character or s for
string
you don't want to do that always in your
code it's sometimes better for your
variables to be more descriptively named
but for a stupid variable that's just
going to count from 0 on up let's just
keep it simple and call it i
i can now do a while loop again but now
i have to ask
a question because i don't want this
running forever i want it running 50
times what question could i ask
well why don't i just check well i is
less than 50.
so it's like counting up on 50 fingers
let me start at 0 and count up 2 but not
through
i equals 50. so so long as i is less
than 50
do the following what do i want to do i
want to keep printing out hello world
hello world hello world
but i'm not done because on every
iteration
of this loop on every cycle of this loop
i need to do one more thing
mathematically i need to add another
finger add another finger
or in other words i need to add one to i
so let me go ahead and set i
equal to whatever it is now plus one but
again we have some syntactic sugar just
to make this a little cleaner a little
tighter
i could do i plus equals one or even
more succinctly
i plus plus so even though this is way
more annoying to implement than in
scratch where mit just gives you what
you want
in c we have all of the building blocks
now with variables
and with uh loops to implement the
notion
of repeating some finite number of times
but there's another way to do this
and as you might have discovered with
problems at zero there's different ways
to achieve the same
goals in scratch similarly in c i could
do this
i could just start counting at one and
count up through
50. so there's no greater than or equal
sign key on your keyboard most likely or
less than or equal to so in c
as with other languages you just use two
characters you do less than sign
followed by the equal sign and that
expresses less than or equal to
so this is also correct if i start
counting at one i need to count
through 50. you can do this don't do
this this is unconventional
and like programmers will conventionally
per last week when we started always
counting from zero with all the light
bulbs off
they'll instead start at zero and count
up 250
which gives you 0 through 49 implicitly
so do this
not that but this does speak to the fact
that you can solve problems in so many
different ways there's another way
fundamentally too we could start
counting
from 50 down to zero the only difference
being
we have to do i minus minus instead of i
plus plus so again that's three
different ways to solve the same problem
and again you'll start to have the right
instincts and muscle memory and you'll
also start to see
common patterns in lecture code your tf
or teaching assistance code
books and references online there just
tend to be the ways to do things
even though all of these are still right
all right
one more approach to loops here it turns
out there's another loop construct
that's a little more cryptic and it's
called a for loop
and it allows you to automate or rather
allows you to express all of those steps
a little more
concisely so for printf
hello world is going to get us one step
closer to printing hello world 50 times
but the for statement just like the
while statement comes with necessary
parentheses after it
but this time you can put more stuff in
the parentheses it's not just a boolean
expression
first the first thing in the parentheses
is you can initialize
any variable you want to some value i
might say in counter equals zero or more
succinctly int
i equals zero semicolon but the way the
for loop looks it's a little funky you
can do multiple things on one line
the second thing inside of the
parentheses to a for loop
is a condition that you want to check
again and again and again and the last
thing
in the parentheses of a for loop is an
update or an incrementation or
decrementation
whereby you can do i equals i plus one
or rather
let's just do i plus equals one or even
more succinctly
i plus plus this is perhaps the most
conventional way
in c and in other programming languages
to do something
50 times or a finite number of times
it's different looking from the things
we've seen thus far there's semicolons
in weirder places
there's more stuff in parentheses so
again you'll develop the muscle memory
overall
but for now just realize this says
initialize i to zero
check the condition and if i is less
than 50 print hello world
then update i then check the condition
if it's less than 50 print hello world
then
increment i then check the condition
then
if it's less than print hello world so
the initialization of the variable
happens once
everything else happens again and again
and again until you've done this
some 50 times all right so with those
building blocks that's kind of it for
our translation of scratch into c
let's now start to build up some more
interesting programs and practice for
instance abstraction
so abstraction recall was this
problem-solving principle
whereby you can simplify otherwise more
complicated
details an abstraction is a
simplification on top of
more complicated details or
implementation details as a programmer
might say
so for instance let me go ahead and
write a program here called meow
similar to last week but this time in c
and in order to
make a cat meow textually let me give
myself standard io.h at the top
in int main void down here
again i'm in a file called meow.c and
i've included standardio.h
and int main void and now i'm going to
go ahead and just do something like this
printf quote unquote meow backslash n
and i want this cat to meow textually
three times
let me save that file make meow
all right now dot slash meow and meow
meow meow all in text so not nearly as
cute or pretty as the one with the cat
last week
but it's it's correct but it's not very
well designed
right because i'm repeating myself i
literally copied and pasted and those
are bad
instincts but now we have the ability to
do things with loops
so let me actually delete this part of
the function and let me try to remember
from the example before if i want to do
something three times i could use a
while loop but that felt like a bunch of
lines of code
let me do this int i equals zero i
less than three i plus plus
so cryptic but this again is sort of the
de facto way
of doing something a finite number of
times initialize some variable
like i to zero check a condition and
keep
incrementing your variable again and
again so that it executes a total of
that many times
now let me go ahead and print f meow on
melo
meow on the inside let me go ahead and
recompile
meow by make meow let me do dot slash
meow and voila
now the program is arguably better
designed but let me take this one step
further recall that the trajectory last
week was to not only implement meow
more uh with better design without
repeating yourself thereby using a loop
but remember we introduced the
abstraction that was a custom puzzle
piece called meow
so in c turns out we have the ability to
make our own
functions as well and the syntax is
going to take a little getting used to
but let me go ahead and do this let me
get rid of my printf here
and at the bottom of my file actually at
the top of my file
i'm going to go ahead and type void main
void
meow void which is very cryptic for
today but again this is fine to be
boilerplate copy pasted for now
let me go ahead and just print f meow
here even though we haven't explained
and won't explain today
what this keyword void means what i've
done in lines three through six is
create my own custom function
c does not come with a function called
meow cs50 is library does not come with
a function called meow
but now thanks to me there exists a
function called meow whose sole purpose
in life
is just to print out meow but what's
cool about this now
is that down here just like with scratch
last week i can now
call a function called meow and my
code's a little more readable because it
rather
says what it does by just by way of the
function's name
and let me go ahead now and compile this
make meow
so far so good dot slash meow and it
seems to work okay
but i don't love the fact that i've
implemented meow at the top of the file
it's not a big deal
by convention we'll typically put custom
functions
at the bottom of the file why only
because when a programmer or in our case
a teaching fellow
wants to understand your code from top
to bottom it's just human convention to
put the main program
the main function rather at the top of
your file
the problem is when i do this i'm going
to have created a problem for myself
when i run make meow
now darn it two errors generated
and so there's a couple of bugs to be
solved but first brian
a question from the group there was a
question that came in from the chat
about
why it is that on like line five for
example right here you don't have a
semicolon at the end of the for loop and
on line 11 you don't have a semicolon at
the end of the function name
so why do some lines need semicolons at
the end of them but other lines don't
really good question why do some of
these lines not have semicolons but
others do
the short answer not to be glib is
honestly just because
the way the language was designed was
that you should generally
finish your thoughts when expressing
verbs or actions or functions
with semicolons and we've seen that
after printf for instance we've just
seen that after meow
however when you're using other
programming constructs like
loops or like custom functions you don't
have semicolons there
why some humans years ago just decided
that we don't need semicolons in those
places and this is one of those things
that it will take a while to develop the
muscle memory and the
sort of mental model for recognizing
where those things go and don't
but thus far the only places we've seen
semicolons are at the ends of functions
like meow and printf here and now
admittedly weirdly inside of the
parentheses
for the for loop but again when tackling
problem said
one and the first lab and so forth
you'll often want to refer back to
examples like these and the slides and
the references in your section
so that you can wrap your mind around
these patterns
so let me go ahead now and solve the two
problems i seem to have created here
it's a little non-obvious but it's
reminiscent of what we've seen before
implicit declaration of function meow is
invalid in c99
c99 is referring to the 1999 version of
c
the language we're using but it's just
getting confused
c is right now well why is that well let
me scroll up here
and let me make the point that frankly c
and in turn my compiler
they're not that bright like they're
only going to do what i tell them to do
explicitly
and the problem at the moment is that
when the compiler reads my code from
top to bottom left to right it is not
until line
11 that the meow function even exists
however i am trying on line seven at the
moment
to use that meow function so my compiler
frankly
just doesn't know what meow is because
it hasn't gotten to meow later and the
compiler is not smart enough
or not user friendly enough to read
everything first and then decide if
there's a problem it's only going to
read it once through top to bottom
and it's going to yell at you the moment
it encounters the problem so the
solution to this is quite simply
move the function to the top of your
file but again that just gets annoying
eventually because then you have to go
fishing for your main function which
might be dozens of lines down in the
file
or there's another way and we'll explain
this in due time too but you can also
copy the very first line only of your
custom function
put it at the top of your file above
main
and then to brian's question and that
with a semicolon so this is weird
this is what's generally known as a
prototype which is a hint
only it's sort of a clever way of
telling the compiler
there will exist a function called meow
but just not yet
but know that it will and it's just kind
of a work around a common work around
for that particular problem all right so
let me go ahead and make one more change
one more change here
suppose that i want to really finish off
this meowing example just like we did in
scratch whereby we
also allow meow to take some number
of meows as input so i don't want to
have this for loop anymore in my main
function
suppose i just want to be able to say
meow
3 inside of my main function 3 there by
being the input to the meow function
i now need to change my custom function
just like i did last week
as follows it turns out and more on this
in the weeks to come
that this mention of void here on line
11
refers to the return value or output of
this function
long story short my custom meow function
today has no
return value it doesn't output anything
per se it instead only has a side effect
of printing visually on the screen but
it does have an input
and if you want a function in c to take
input or
arguments you can literally do something
like the name of the type you want
and the name of the variable that you
want so suppose i want meow to take as
input some number we'll call it n
and i want to use that number in a loop
i could then do something like this
for int i gets 0 i is less than
n i plus plus i can then surround my
printf
with curly braces and now notice just
like last week with my final
implementation of now
my custom function can take input as
denoted by the parentheses
it doesn't have output per se that's why
i'm leaving void here but again we'll
explain void more
in detail down the road but now i'm
using that input
inside of the for loop so even though
this is a new
implementation in c i'm using the same
building blocks i'm using a for loop
i've like before but instead of hard
coding three or 50 like i did earlier
now i'm actually going to go ahead and
just plug in that variable
just like scratch allowed me to do as
well
what if i want to do something even
fancier you know what let me go ahead
and do this suppose that we want to get
input from the user
but we really want them to provide a
specific type of input
let me go ahead and introduce one other
type of loop and this one i'm going to
go ahead and grab for my archives the
code that i brought
with me today and i'm going to go ahead
and copy over a file
called positive.c which is going to
insist that the user give me a positive
value
so this too is on the course's website
let me just walk us through code that i
already wrote
here at the top of my file i'm including
some now familiar header files
and down here i'm including a prototype
that is a hint
for a function that's going to be called
quite simply get positive int
so this is a function that's only going
to get a positive integer then in my
main function
notice i'm going to use this i'm going
to get a variable called i
on line 10 and i'm going to get a
positive in from the user
and then i'm just going to print it out
but what's interesting now is
i have this additional abstraction the
cs50 library does not come with a
function called getpositiveint
but it does come with a function called
getint and notice what i've done down
here between lines 15 and 24.
down here i've declared a function
called getpositiveint
and notice that's my own custom function
name it doesn't take any inputs it just
gets a positive integer from the human
but now notice
it does have a return value previously i
used the word void to say the absence of
input or the absence of output here i'm
using it still to say
no inputs it just always gets a positive
end but i'm saying
int on the left hand side of this custom
function's name because this function
does have
output what is the output going to be
well notice here on line
17 i give myself a variable and i call
it n then i have one final new feature
of c today this loop
which is called not a while loop but a
do while loop
a do while loop is almost the same as a
while loop
except that it blindly does one thing
first
before checking a condition so notice
here i'm going to do the following
call getint with this prompt positive
integer and then store the return value
into the variable called n then down
here notice i'm saying
while n less than one so this is kind of
a weird syntax
but if mathematically i want the user to
give me a positive integer
that's technically the same thing as
wanting the user to give me an integer
and just make sure that it is not
less than one because if it's less than
one it's zero or negative one or
negative two that's obviously not a
positive integer so how can i express
this in code
the only new thing at the moment now is
the fact that there exists this thing
called do while and again the value of
do while
is that you will do things at least once
and then
check a condition a while loop checks
the condition first
and then does something instead this is
what i want in this case though i want
to do this
get a positive get an integer from the
user prompting them for a positive
integer
then while n is less than one
so if the human typed in zero or
negative one or negative two what do i
wanna do
the same thing again and again and again
so it reads rather grammatically
do the following while n is less than
one
and then lastly and the only other new
line here is return
n this is the way that a program can
actually return
some value to you it can hand you back a
value not by printing it on the screen
not by saying it audibly or visually
from a cat's mouth
it returns it in the sense that what's
being returned here is n
which is an integer that matches the
output of this function
why is this useful well let's scroll
back up let's now take for granted
that the get positive in function exists
and now notice
how we can use it in main i call get
positive int on the right
it returns a value i claim that is of
type integer
i'm storing that return value on the
left in this variable called i
and then i'm printing out i and just
like last week with the meow example in
scratch
now that i have implemented get positive
in it's sort of out of sight out of mind
i know that it can be done and i can
abstract away
the underlying implementation details by
just
calling it by its name but there's one
weird thing
i do want to point out about these
implementation details
why did i declare n out here
every other time i've created a variable
i've done this
does anyone want to conjecture why
this approach where i declare n on line
27 to be an int
would actually not work correctly
any thoughts
why might this not be correct this is
subtle
and if you have programmed before you
might have the instincts for this or
if you haven't perhaps just a bit of
intuition
why might this not work as is
uh yeah over to uh abigail
abigail why does this not work are we
catching you off guard
um
i'm not certain i think we've already
assigned that
it is an integer a good good thinking
not the correct answer in this case
it's not going to work for a more subtle
reason here
and that actually in some sense has to
do with these curly braces it turns out
we've been getting lucky this whole time
and any time i've declared variables
they've technically been in between
curly braces the curly braces belonging
to the main function
or my other functions that i've written
thus far
but in this case the problem is when you
declare a variable
inside of curly braces you run into what
we'll call an issue of scope
the scope of a variable is the lines of
code in which it exists
the scope of a variable are the lines of
code where you can use
that variable and the rule of thumb for
today
is that if you declare a variable inside
of curly braces like those here on line
26 and 28 which you must do
for a do while loop that variable n only
exists inside of those curly braces
which means you cannot compare it
against
one in line 29 which means you cannot
return it
in line 30 it just no longer exists so
you're doing all of this work getting
the variable n and then
boom it's gone once you exit
top to bottom these curly braces so the
work around for that
stupid though it is frankly is that you
can declare an initially on its own line
25
you don't need to assign it a value even
because you're going to assign it a
value eventually
but again to create a variable as i keep
saying is to declare a variable
you don't need to define it as having a
value necessarily
right away so this is a way to work
around what's otherwise known as
an issue of scope all right with all of
these puzzle pieces now in place so to
speak
let me go ahead and propose that we
solve something a little more graphical
so you'll recall of course
super mario brothers is we uh one of the
first problem sets that we alluded to
last week and within this game there's a
whole bunch of visuals
for instance there's this visual early
on where there's four question marks in
the sky
and these question marks if you jump up
and underneath them give you coins for
instance so let me draw our attention to
that and let me ask
well how could i write a program in c
that just prints out for question marks
well let me go ahead and do this let me
go ahead and write a program called
mario.c
let me go ahead and include uh
standardio.h
in a file called mario.c give myself a
main function in main void i'm going to
keep this simple
printf1234 backslash n semicolon this is
not nearly as cool or pretty as the
old school game but if i run make mario
and then do dot slash mario voila i get
a very
uh poor approximation of these
four blocks in the sky using just ascii
or
really what is called ascii art but i
can do a little better than that
recall that now we have the ability to
use loop so i could say for
int i gets 0 i is less than 4
i plus plus and then i could just print
out
one question mark at a time and then at
the very end of my program i could print
out a new line
just to move the cursor at the very last
moment i don't want to do that
every question mark because then it
would be vertical i want to do it only
at the end
so now if i make mario and i run mario
now
same exact result but a little better in
the sense that it
is um now uh more dynam
now it's uh using a loop instead of a
hard-coded value
but let me be a little more clever now
and let me do this instead
let me borrow the logic of that positive
integer example and do something like
this let me give myself a variable
called
n for a number and let me do the
following just like before
let me get an integer from the user and
ask the user for the width
of the bricks that i want to print so
it's not always four maybe it's a
variable number
and then let me go ahead and do this
while n is less than one so identical
to my logic before and then you know
what once i have a value of
n so let me go ahead up here and give
myself a comment
get positive integer from user that
rather says what all of these lines of
code do i don't need to comment every
single line
you can comment every few if it makes
logical sense to do so
let me go ahead now and print out that
many
question marks so i can do a loop for
int
i gets 0 i is less than n this time i
plus plus and now i can print out a
single question mark without a new line
and then at the very end of my program i
can print out a single new line
semicolon let me go ahead now and
increase the size of my terminal window
let me do make mario and now oh
darn it implicit declaration of function
get int
here's where help50 might be my friend
so let me go ahead and run help50 make
mario
it's going to ask for help ah you seem
to have an error in mario.c
on line 9 by implicit declaration of
function getint clang means which is the
name of the compiler which we'll see
next week
means that it doesn't recognize getint
did you forget to include cs50.h
in which inkgetint is declared i type
your file and indeed i did so let me fix
this
so include cs50.h
save the file recompile with make mario
and now let me go ahead and may and do
dot slash mario
and i'll give myself a width of four
it's the same let me give myself
a width of 40. now i get that dynamism
let me give myself a width of 50
and so forth so now we have a program
that's much more dynamic
but you know what let's go ahead and
enhance this a little further
later on in super mario brothers there's
like a lot of this underworld here where
you see these grids of bricks and let me
draw our attention to this
this looks like multiple bricks both
horizontally and
vertically so there's like a width and a
height so how can i go about printing
out maybe maybe that's three by three
three bricks across by three bricks down
let me actually go into my program here
and get rid of all the question mark
stuff from before
and consider how i could print out a
three by three grid well
the bad approach here if i go back into
my code
would be to print out three of these and
then maybe
three more whoops maybe three more and
then three more
but of course this copy paste is not
going to fly long term but that's fine
let me do make mario dot slash mario
all right i kinda sort of have a grid
that looks like this thing here it's not
exactly but at least it's the right idea
but this is not necessarily the best way
to do this i really want to go
three across and three down well it
turns out
using c we can actually express that
as well let me go ahead and do this let
me go ahead and print out for instance
the following let me go ahead and print
out not just
hash again and again and again let me go
ahead and do this
let me print out one row at a time so
for int
i gets 0 i less than 3 i plus plus
i don't know what i'm about to do yet
but i know that i'm going to do it three
times
what do i want to do three times well i
want three rows and on every row i want
three hashes so you know what you can do
you can nest loops let me do four int j
gets zero
j is less than three and j plus plus i
don't know what i'm going to do yet but
i do know i'm going to do this
three times and you can perhaps see
where this is going three things three
times that's going to give me all nine
bricks
so long as inside of this inner loop
so to speak this nested loop i print one
of those hashes
so long as after that loop i print out a
new line
over here so to be clear even if it's
not obvious at first glance what's going
on
we already know that this is the type of
syntax you use
for doing something finitely many times
three this is the same syntax but i'm
using a different variable name so i can
keep track of two different values
essentially rows and columns
and then i'm just printing a single
brick each time but after i'm done
printing a whole row
i do want to move the new cursor to a
new line
so let me try this let me go ahead and
do make mario on my code
dot slash mario and voila now i'm using
a nested loop to print out bricks like
this and i can change this if i want to
do a 10 by 10
all i have to do is change that in one
place or if i really wanted to be fancy
i could go use get int again
i could get the width and the height
from the user and do it completely
dynamically but now if i do 10 by 10
for instance i can at least see an even
bigger grid so if you wonder how things
like super mario bros or frankly any
game nowadays on a pc
or console or phone or made it's with
this kind of generation of maps maybe
back in the day they were hard-coded
maybe they were generated
using code you can absolutely imagine
generating brick after brick after brick
like that
so that ultimately your game even your
world is partly dynamically generated
and we already have the building blocks
via which to do that unfortunately we
haven't
really spoken to the limitations of what
computers can do
and in our final minutes we thought we'd
set the stage for things that computers
aren't very good at and in fact problems
that are exist
that are latent in pretty much
everything we've done today but i've
been very carefully avoiding tripping
over
this picture here is a picture of a
typical computer's memory or ram
random access memory it's just one of
the pieces of hardware that you'd have
in your phone
your desktop your laptop these days and
it's where programs are stored
when they're running so on a mac or pc
if you double click a program
it's ultimately stored in a piece of
hardware that looks like this when you
do
dot slash mario and hit enter in a
program like this you're using cs50
ide's ram
but same idea albeit somewhere else in
the cloud
so it turns out though that if you only
have a finite amount of memory like this
you can only do so much with it you
can't solve all of the world's problems
if you only have a finite amount of
memory
and what do i mean by that well let me
go ahead and create
another program here called
imprecision.c
and we'll see why i've named it that in
just a moment let me go ahead and
include
standardio.h again in in main void just
to give myself some setup here
and then let me go ahead and very
reasonably very simply ask the user for
a variable called x as a type float let
me ask for the
value just like before let me ask for
another one in the form of y
quote-unquote y and then let me go ahead
and
let me go ahead and print out with
percent f
the value of x divided by y so i'm
pretty sure we did this earlier we did
division
with values this time i'm using floats
but let's go ahead and just run this
make imprecision oh and i goofed here
implicit
keep doing it implicit declaration of
function get flow
i didn't practice what i've been
preaching i also need to include
cs50.h which is where getfloat is
defined
now let me recompile now it works now
let me go ahead and run imprecision
and let me go ahead and type in 1 uh
10th
okay so 1 10th it turns out according to
my very simple calculator here
is 0.10
but i'm getting a little curious now it
turns out that printf
is even more powerful than we've seen
and you can actually print out more than
just single digits
suppose i want to print out not six
significant digits but maybe 10. it's a
little funky the syntax but instead of
saying percent f
you can instead say literally percent
dot
the number of digits you want to see and
then the f
so let me go ahead and recompile this
make imprecision
now let me do dot slash imprecision and
one tenth
ha ha well that's a little curious
i don't recall knowing that there's a
one five at the end of one tenth
well let's get a little more curious
let's print out 50 decimal points to
really dig into what's going on here
let me recompile my code and let me
rerun dot slash imprecision and do 1
divided by 10 and oh my god like i am
quite sure in grade school when we all
learned 1 divided by
10 the teacher did tell us 1 10 or 0.1
and they never mentioned the fact that
it's 0.1000001490116
and so forth so what is going on well it
turns out as powerful as computers are
and is
as sophisticated as all of the syntax
we've been looking at today is
my god a computer you can't even
calculate one-tenth
correctly and so we're bumping up
against a fundamental limitation here
which is that if computers are
finite in their capacity they only have
so much
ram so much hardware so many bits well
it stands to reason that if you only are
using a finite number of bits
32 for instance or 64 yes you can count
pretty high or pretty precisely you
cannot count
infinitely high or infinitely precisely
at some point
you have to start to approximate values
and indeed that's what the computer is
doing
if it only has a finite number of bits
32
via which to represent a float there's a
infinite number of floating point
real numbers in the world unfortunately
if you have a finite number of bits you
got to start cutting some corners and
that's what the computer is doing
it's representing one tenth as closely
as it can
and this is what you then see when you
look enough significant digits out now
for most
problems that's probably not a big deal
but it could very well be a big deal if
you're doing math you're dealing with
finance
or monetary values or military
operations where a lot of small numbers
uh scientifically really start to add up
and indeed there have been many examples
in the real world where bad things
happen
because of this so-called imprecision
and there's another
issue that computers run into not only
this floating point in precision
even integers have their limitations
recall that integers of course
can be represented in decimal or in
binary and if we have three light bulbs
or three bits let's consider how we
might count in binary
zero zero zero is where we began last
week zero zero one
zero one zero zero one one one zero zero
one zero one one one zero one one one
and now
this recall from last week is the number
we know is seven in decimal
how do i count one digit higher well i
just
carry the one so to speak but if i only
have three light bulbs or in turn three
bits
or heck 32 bits that additional bit the
carry
disappears and so there's this problem
with integers too
and someone noted it earlier when we
tried to do two billion or when you
tried to do two billion plus two billion
it couldn't fit in the result that's
because integers two
if they're only 32 bits or a long in c
if it's only 64 bits those are big
numbers but they're not
infinitely large and we humans have
tripped over this again and again
you might recall hearing about if not
living through the y2k problem
where a lot of stuff in the world broke
or was worried to be broken
on january 1st 2000 because humans had
made the
reasonable but not very long-sighted
decision to store
years using just two digits so 1995
would be represented as 9.5
96 97 98 99 then
around the change of the year from 1999
to 2000
any computer program or system that was
still using two digits
would of course add one at the stroke of
midnight unfortunately if there's no
third digit
available it disappears and the entire
world confuses the year 2000
for the year 1900 because 1900 was
assumed
as being the prefix and if you can
believe it we humans are about to do
this again
in the year 2038 which is not that far
off from now
we are going to run out of bits
by which to keep track of time because
years ago humans decided reasonably at
the time
they are going to use 32 bits to
represent numbers
and we are going to use 32 bits to count
up
the number of seconds from the year a
date
january 1st 1970. so that's when time
began computing wise in some sense and
we've been counting the seconds ever
since
unfortunately with 32 bits you can only
count as high as 4 billion give or take
and unfortunately we are going to hit
the 4 billionth second on
january 19th in the year 2038 so unless
all of us upgrade our macs and pcs and
worse embedded systems and satellites
and any hardware
baked into various devices that we now
use we're about to run into this problem
again where all of a sudden it's going
to be like january 1st
1970 again unless we stay ahead of this
problem
so with all the power we've seen and see
and all of the capabilities we've seen
in c
and in scratch there are still these
fundamental limitations so when it comes
to solving your own problems in
c and in turn cs50 it's going to be ever
so important to be mindful of these
constraints and to ultimately find
solutions even to these problems but for
now
we'll adjourn here and leave you for
your first problem set in c
on mario and more we'll see you next
time
you
